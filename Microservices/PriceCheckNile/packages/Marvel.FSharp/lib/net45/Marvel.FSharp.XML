<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Marvel.FSharp</name></assembly>
<members>
<member name="">

</member>
<member name="M:FSharp.Data.Runtime.TextConversions.AsString(System.String)">
<summary>
 Turns empty or null string value into None, otherwise returns Some
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Data.Runtime.TextConversions.AsFloat(System.String[],System.Boolean,System.IFormatProvider,System.String)">
<summary>
 if useNoneForMissingValues is true, NAs are returned as None, otherwise Some Double.NaN is used
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.Data.Runtime.TextConversions.AsDateTime(System.IFormatProvider,System.String)">
<summary>
 Parse date time using either the JSON milliseconds format or using ISO 8601
 that is, either &quot;\/Date(&lt;msec-since-1/1/1970&gt;)\/&quot; or something
 along the lines of &quot;2013-01-28T00:37Z&quot;
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.Data.Runtime.TextConversions">
<summary>
 Conversions from string to string/int/int64/decimal/float/boolean/datetime/guid options
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.Data.Runtime.Helpers.asOption``1(System.Boolean,``0)">
<summary>
 Convert the result of TryParse to option type
</summary>
</member>
<member name="T:FSharp.Data.Runtime.Helpers">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Aggregate`3">
<summary>
 An event-based aggregate abstraction.
</summary>
</member>
<member name="F:Marvel.Marvel.ArgAttribute.Default@">
<summary>
 An optional default value to use if none is found in the source.
 If a default is not provided, the argument is considered mandatory
 such that parsing will fail if a value isn&apos;t provided by an argument source.
</summary>
</member>
<member name="F:Marvel.Marvel.ArgAttribute.Key@">
<summary>
 The key to use to lookup this argument in an argument source.
</summary>
</member>
<member name="P:Marvel.ArgAttribute.Key(System.String)">
<summary>
 The key to use to lookup this argument in an argument source.
</summary>
</member>
<member name="P:Marvel.ArgAttribute.Default(System.Object)">
<summary>
 An optional default value to use if none is found in the source.
 If a default is not provided, the argument is considered mandatory
 such that parsing will fail if a value isn&apos;t provided by an argument source.
</summary>
</member>
<member name="P:Marvel.ArgAttribute.Key">
<summary>
 The key to use to lookup this argument in an argument source.
</summary>
</member>
<member name="P:Marvel.ArgAttribute.Default">
<summary>
 An optional default value to use if none is found in the source.
 If a default is not provided, the argument is considered mandatory
 such that parsing will fail if a value isn&apos;t provided by an argument source.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.ArgAttribute">
<summary>
 Indicates the name an argument has within a specific namespace and an optional default value.
 An absence of a namespace makes it the default.
</summary>
</member>
<member name="T:Marvel.ArgSource">
<summary>
 A source of argument values which given a set of keys returns the corresponding key/value pairs.
 Examples: command line, environment, config file, consul.
</summary>
</member>
<member name="T:Marvel.AsyncArrow`2">
 <summary>
 An async arrow is a function which produces an async computation as output.
 </summary>
 <remarks>
 This is a specialization of a Kleisli arrow to Async.
 There are numerous interpretations - for example, it can represent an async request/reply protocol which 
 can itself represent database reads, writes, etc.
 </remarks>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncCell`1">
<summary>
 An async storage cell.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncCh`1.Take">
<summary>
 Creates an async computation which completes when a value is available in the channel.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncCh`1.Fill(`0)">
<summary>
 Creates an async computation which completes when the provided value is read from the channel. 
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncCh`1.EnqueueFill(`0)">
<summary>
 Queues a write to the channel.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.AsyncCh`1">
 <summary>
 A CML-style channel with synchronous rendezvous.
 </summary>
 <remarks>
 Note the "async" in the name can be misleading. The channel is async in that it uses Async for completion notification
 however the semantics of the channel is syncrhonous. This means that a write completes when a matching read is found not when
 there is nothing else in the channel.
 A channel can be used to serialize logic across async workflows.
 </remarks>
</member>
<member name="T:Marvel.AsyncCodec`3">
<summary>
 An decoder to from type &apos;i and encoder to type &apos;o for type &apos;a where encoding may be an IO-bound
 operation. Decoding errors are represented as strings.
</summary>
</member>
<member name="T:Marvel.AsyncFilter`2">
<summary>
 A simplified filter where the input and output types of the mapped arrows don&apos;t change.
</summary>
</member>
<member name="T:Marvel.AsyncFilter`4">
<summary>
 An AsyncFilter is a mapping between arrows allowing for the input and output types to change.
</summary>
</member>
<member name="T:Marvel.AsyncIn`1">
<summary>
 Consumes values of type &apos;i eventually stopping.
</summary>
</member>
<member name="T:Marvel.AsyncIn`2">
<summary>
 Consumes values of type &apos;i eventually returning value &apos;a.
</summary>
</member>
<member name="T:Marvel.AsyncIoCh`2">
<summary>
 An input/output channel.
</summary>
</member>
<member name="T:Marvel.AsyncObservable`1">
<summary>
 An async observable.
</summary>
</member>
<member name="T:Marvel.AsyncObserver`1">
<summary>
 An async observer.
</summary>
</member>
<member name="T:Marvel.AsyncOut`1">
<summary>
 Emits values of type &apos;a eventually stopping.
</summary>
</member>
<member name="T:Marvel.AsyncOut`2">
<summary>
 Emits values of type &apos;a eventually returning with value &apos;a.
</summary>
</member>
<member name="T:Marvel.AsyncParSeq`1">
<summary>
 A sequence of async computations.
</summary>
</member>
<member name="T:Marvel.AsyncPipeEx`2">
<summary>
 An async pipeline which may produce an exception.
</summary>
</member>
<member name="T:Marvel.AsyncPipeStep`3.Await">
<summary>
 The pipeline is consuming a value of type &apos;i.
</summary>
</member>
<member name="T:Marvel.AsyncPipeStep`3.Emit">
<summary>
 The pipeline is emitting a value of type &apos;o.
</summary>
</member>
<member name="T:Marvel.AsyncPipeStep`3.Done">
<summary>
 The pipeline completed with result &apos;a.
</summary>
</member>
<member name="T:Marvel.AsyncPipeStep`3">
<summary>
 An individual step in an async pipeline.
</summary>
</member>
<member name="T:Marvel.AsyncPipe`2">
<summary>
 An async pipeline which produces no output at the end.
</summary>
</member>
<member name="T:Marvel.AsyncPipe`3">
<summary>
 An async pipeline which consumes values of type &apos;i, produces
 values of type &apos;o and completes with a result &apos;a or an error.
</summary>
</member>
<member name="T:Marvel.AsyncProc`2">
<summary>
 An async transducer of input of type &apos;I to output of type &apos;O.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncSeqInner`1">
<summary>
 The interanl type that represents a value returned as a result of
 evaluating a step of an asynchronous sequence
</summary>
</member>
<member name="T:Marvel.AsyncSeq`1">
<summary>
 An asynchronous sequence represents a delayed computation that can be
 started to produce either Cons value consisting of the next element of the 
 sequence (head) together with the next asynchronous sequence (tail) or a 
 special value representing the end of the sequence (Nil)
</summary>
</member>
<member name="T:Marvel.AsyncSink`1">
<summary>
 An async sink - consumes a value resulting in a unit returning async computation.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.AsyncStreamNode`1">
<summary>
 AsyncStream a = Cofree Async a
</summary>
</member>
<member name="T:Marvel.AsyncStream`1">
<summary>
 An infinite async sequence.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.ByteCodec`1">
<summary>
 A codec between a type &apos;a and a byte array.
</summary>
</member>
<member name="T:Marvel.Channel`2">
<summary>
 An effectful channel (a source of functions).
</summary>
</member>
<member name="T:Marvel.CoState`2">
<summary>
 CoState comonad (Store comonad).
 Intuitively, this structure represents a context containing
 a value of type &apos;s and a function to map a value of type &apos;s to a value of type &apos;a which is the larger context
 and the type that varies under compositon.
</summary>
</member>
<member name="T:Marvel.Codec`2">
<summary>
 A codec for raw type &apos;m to type &apos;a.
</summary>
</member>
<member name="T:Marvel.Codec`3">
<summary>
 An decoder to from type &apos;i and encoder to type &apos;o for type &apos;a.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.DList`1">
<summary>
 Difference list (John Hughes append list).
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.EnumConverter.installFor``1">
<summary>
 Install an EnumConverter for enum of type &apos;e into the global TypeDescriptor to allow for
 automatic conversion.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.EnumConverter">
<summary>
 A very generalized enum converter since .NET doesn&apos;t provide one.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Filter`4">
<summary>
 A filter is an aspect in the AOP sense.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.IVar`1">
<summary>
 A write-once variable which supports Async-based notification.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.IntHistogram">
<summary>
 Measures averages, max and percentiles.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.LogLevelConverter.install">
<summary>
 Install a LogLevelConverter into the global TypeDescriptor to allow for automatic conversion.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.LogLevelConverter">
<summary>
 A type converter for NLog&apos;s LogLevel type since none is provided for us.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.PLens`2">
<summary>
 Partial lens.
</summary>
</member>
<member name="T:Marvel.Rand`1">
<summary>
 A random value represented as a transition from an RNG to a random value and the next state of the RNG.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Setter`2">
<summary>
 A field setter.
</summary>
</member>
<member name="T:Marvel.Sink`1">
<summary>
 A process which awaits values of type &apos;O and produces no output.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Source`1">
<summary>
 A source of values of type &apos;O
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.State`2">
<summary>
 The state monad - a transition from a state, to a value and a new state.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.StringCodec`1">
<summary>
 A codec between a type &apos;a and a string.
</summary>
</member>
<member name="T:Marvel.Tee`3">
<summary>
 An async process which accepts inputs of type &apos;I1 or &apos;I2.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.These`2">
<summary>
 A value that can be this, that, both or neither.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.TimedCounter">
<summary>
 Measures averages, max and percentiles.
</summary>
</member>
<member name="T:Marvel.Update`3">
 <summary>
 Update monad - a function which takes a state 's as input and produces an update 'u and a value of type 'a as output.
 </summary>
 <remarks>http://cs.ioc.ee/~tarmo/papers/types13.pdf</remarks>
</member>
<member name="">

</member>
<member name="T:Marvel.Void">
<summary>
 A type which is not inhabited by any values.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Aggregate.handleAppend``3(Marvel.Aggregate{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Control.FSharpAsync{System.Collections.Generic.IEnumerable{``2}}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},System.String,``1)">
<summary>
 Creates a handler for an aggregate which when processing input, reconstituted the current state based on past outputs, executes the input and persists the resulting output.            
</summary>
</member>
<member name="M:Marvel.Aggregate.handle``3(Marvel.Aggregate{``0,``1,``2},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Control.FSharpAsync{System.Collections.Generic.IEnumerable{``2}}},System.String,``1)">
<summary>
 Creates an input handler for an aggregate given an output source (event store).
</summary>
</member>
<member name="M:Marvel.Aggregate.currentState``3(Marvel.Aggregate{``0,``1,``2})">
<summary>
 Gets the current state of an event-sourced aggregate given a sequence of past outputs (events).
</summary>
</member>
<member name="T:Marvel.Aggregate">
<summary>
 An event-sourced aggregate.
</summary>
</member>
<member name="M:Marvel.Arg.injectConsul``1(System.String)">
<summary>
 Creates an instance of &apos;a and binds consul settings.
</summary>
</member>
<member name="M:Marvel.Arg.injectEnv``1">
<summary>
 Creates an instance of &apos;a and binds environmenal variables.
</summary>
</member>
<member name="M:Marvel.Arg.injectCli``1">
<summary>
 Creates an instance of &apos;a and binds command line arguments.
</summary>
</member>
<member name="M:Marvel.Arg.parseCli">
<summary>
 Parses command line arguments from the environment.
</summary>
</member>
<member name="M:Marvel.Arg.require(System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Collections.FSharpMap{System.String,System.String})">
<summary>
 Checks for existence of keys in the argument set and if any are missing returns Choice2Of2 with
 all of the missing keys, otherwise returns the original argument set.
</summary>
</member>
<member name="T:Marvel.Arg">
<summary>
 Top level operations on arguments and argument sources.
</summary>
</member>
<member name="M:Marvel.ArgSources.Consul(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 An argument source which retrieves keys from consul.
</summary>
</member>
<member name="M:Marvel.ArgSources.Env(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Gets argument values from environmental variables.
</summary>
</member>
<member name="M:Marvel.ArgSources.Cli_(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Gets argument values from the command line.
</summary>
</member>
<member name="M:Marvel.ArgSources.Cli(System.String[],System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Gets argument values from the command line.
</summary>
</member>
<member name="M:Marvel.ArgSources.resolve(Microsoft.FSharp.Collections.FSharpMap{System.String,System.String},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Collections.FSharpMap{System.String,System.String}})">
<summary>
 Resolves arguments from a provider given a set of keys and defaults.
</summary>
</member>
<member name="M:Marvel.ArgSources.mergeAll(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Collections.FSharpMap{System.String,System.String}}},System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Merges a list of argument sources ordered by lowest to highest precedence, into a composite argument source.
 Values from source i will override values from source j if i > j.
 </summary>
 <param name="ps"></param>
</member>
<member name="P:Marvel.ArgSources.empty">
<summary>
 An empty argument source.    
</summary>
</member>
<member name="M:Marvel.ArgSources.konst(Microsoft.FSharp.Collections.FSharpMap{System.String,System.String})">
<summary>
 An argument source which returns a fixed set of arguments regardless of provided keys.
</summary>
</member>
<member name="T:Marvel.ArgSources">

</member>
<member name="M:Marvel.ArgsCli.parse(System.String[])">
 <summary>
 Parses command line arguments.
 </summary>
 <param name="args"></param>
 <returns></returns>
 <remarks> 
 <![CDATA[
   <args>       ::= {<arg>}
   <arg>        ::= <arg-prefix> <arg-name> [[=|:]<arg-value>]
   <arg-name>   ::= <alphanum>
   <arg-value>  ::= <alphanum>
   <arg-prefix> ::= "--"
   <alphanum>   ::= [A-Za-z0-9_-]
 ]]>
 </remarks>
 <example>
 --eventstore-host nova-eventstore --profx-host http://profx-elasticsearch:9200/ --active
 --flags foo bar baz
 </example>
</member>
<member name="T:Marvel.ArgsCli">
<summary>
 Command line argument parsing.
</summary>
</member>
<member name="M:Marvel.ArgsReflect.bind``1(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Collections.FSharpMap{System.String,System.String}})">
<summary>
 Binds to a structure &apos;a using the specified provider.
</summary>
</member>
<member name="M:Marvel.ArgsReflect.injectArgsInto(System.Object,Microsoft.FSharp.Collections.FSharpMap{System.String,System.String})">
<summary>
 Injects arguments into an object.
</summary>
</member>
<member name="M:Marvel.ArgsReflect.injectArgsIntoErr(System.Object,Microsoft.FSharp.Collections.FSharpMap{System.String,System.String})">
<summary>
 Injects arguments into an object returning an array of errors, if any.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.ArgsReflect.getAllArgKeys(System.Type)">
<summary>
 Gets all the argument metadata for the specified type.
</summary>
</member>
<member name="M:Marvel.ArgsReflect.resolveArgDefaultAndKeys(System.Reflection.PropertyInfo)">
<summary>
 Gets the default value of an arg mapped to the specified property
 and the set of argument keys to lookup.
</summary>
</member>
<member name="M:Marvel.ArgsReflect.defaultArgKeys(System.Reflection.PropertyInfo)">
<summary>
 Gets a list of default argument names for a property
 which include the name of the property in lower case as well as 
 an expansion with &apos;_&apos; replaced by &apos;-&apos;.
</summary>
</member>
<member name="T:Marvel.ArgsReflect">
<summary>
 Argument helpers based on reflection.
</summary>
</member>
<member name="M:Marvel.Array.zipWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[],``1[])">
<summary>
 Makes an array, its elements are calculated from the function and the elements of input arrays occuring at the same position in both array.
 The two arrays must have equal length.    
</summary>
</member>
<member name="M:Marvel.Array.contains``1(``0,``0[])">
<summary>
 Determines whether an array contains a value.
</summary>
</member>
<member name="M:Marvel.Array.pairs``1(``0[])">
<summary>
 Projects an array of even size onto an array of subsequent pairs.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Array.last``1(``0[])">
<summary>
 Gets the last element in an array.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Array">

</member>
<member name="M:Marvel.ArraySegment.toArray``1(System.ArraySegment{``0})">
<summary>
 Copies the segment to a new array.
</summary>
</member>
<member name="M:Marvel.ArraySegment.add``1(``0,System.ArraySegment{``0})">
<summary>
 Assigns a value to the position in the array immeditatly after the segment and expands the segment.
 Note that the underlying array has to have sufficient space.
</summary>
</member>
<member name="M:Marvel.ArraySegment.widen``1(System.Int32,System.ArraySegment{``0})">
<summary>
 Widens the segment by the specified length.
</summary>
</member>
<member name="M:Marvel.ArraySegment.asMemoryStream(System.ArraySegment{System.Byte})">
<summary>
 Initializes a memory stream with the range represented by the array segment.
</summary>
</member>
<member name="M:Marvel.ArraySegment.ofMemoryStream(System.IO.MemoryStream)">
<summary>
 Exposes the underlying buffer as an array segment sized to the appropriate length. 
 Note if the memory stream is mutated after this operation, the underlying array will change.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.ArraySegment">

</member>
<member name="">

</member>
<member name="T:Marvel.ArraySegmentExtensions">

</member>
<member name="M:Marvel.AsyncArrow.histogramNamed``2(System.String)">
<summary>
 Outputs latency in milliseconds such that a histogram is printed every second into a provided log.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.histogram``2(Marvel.IntHistogram,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Outputs latency in milliseconds such that a histogram is printed every second into a provided log.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncArrow.countAndTimeAfterBatch``2(Marvel.TimedCounter)">
<summary>
 Counts invocations of a service using a timer which aggregates counts and prints results to the console every second.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.countAndTimeAfterNamed``2(System.String)">
<summary>
 Counts invocations of a service using a timer which aggregates counts and prints results to the console every second.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.countAndTimeAfter``2(Marvel.TimedCounter)">
<summary>
 Counts invocations of a service using a timer which aggregates counts and prints results to the console every second.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.after``2(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Creates an arrow which first invokes f then g with the results of f. The results (but not side-effects) of g are discarded.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.retryAllBackoff``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}})">
<summary>
 Retries the operation performed by the arrow with a specified number of attempts and back-off strategy.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.retryAll``2(System.Int32)">
<summary>
 Retries the operation performed by the arrow with
</summary>
</member>
<member name="M:Marvel.AsyncArrow.catchLogIgnore``2(NLog.Logger)">
<summary>
 Catches exceptions and logs them in the specified logger and ignores.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.catchNotifyIgnore``2(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Exception},Microsoft.FSharp.Core.Unit})">
<summary>
 Catches exceptions and notifies the provided callback and ignores.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.logErrorsTo``3(NLog.Logger)">
<summary>
 Logs errors (Choice2Of2) into the specified logger.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.printInOut``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Prints the input into an arrow before invoking it and prints the output after.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.notifyErrors``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Core.Unit})">
<summary>
 Creates an arrow which calls the specified callback function when an error &apos;e occurs.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.andThenChoices``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``4}}})">
<summary>
 Composes two arrows returning Choice values such that Choice2Of2 is interpretted as a failure and propagated.
 (AsyncArrow.composeChoices with arguments flipped).
</summary>
</member>
<member name="M:Marvel.AsyncArrow.composeChoices``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``3,``4}}})">
<summary>
 Composes two arrows returning Choice values such that Choice2Of2 is interpretted as a failure and propagated.
 AsyncArrow.andThenChoices with arguments flipped.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.andThenTry``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}}})">
<summary>
 Creates an arrow which first runs arrow g then if it returns a successful result runs f otherwise it
 propagates the error &apos;e.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.andThenTry_``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``4}}})">
<summary>
 Creates an arrow which first runs arrow g then if it returns a successful result runs f otherwise it
 propagates the error &apos;e1. If the arrow f fails, the error &apos;e2 is propagated.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapErrorAsync``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``3,``0}}})">
<summary>
 Maps over the erroneous output of an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapSuccessAsync``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``3}}})">
<summary>
 Maps over the successful output of an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapError``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``3,``0}}})">
<summary>
 Maps over the erroneous output of an arrow.
 Reference implementation: f |&gt; AsyncArrow.mapr (Choice.mapr g)
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapSuccess``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``3}}})">
<summary>
 Maps over the successful output of an arrow.
 Reference implementation: f |&gt; AsyncArrow.mapr (Choice.mapl g)
</summary>
</member>
<member name="M:Marvel.AsyncArrow.tryCompose``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``3,``2}}})">
<summary>
 Creates an arrow which first runs arrow g then if it returns a successful result runs f otherwise it
 propagates the error &apos;e.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncArrow.tryAfter``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``2}}})">
<summary>
 Invokes the arrow g with the successful result &apos;b of arrow f. If f returns a failure no action is performed.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.tryBefore``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,``1}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Invokes the arrow g before arrow f. If g returns a left choice value which contains the input to f, 
 the resulting arrow will continue. Otherwise the right choice value is propagated.
 Reference implementation: g &gt;&gt;&gt; (AsyncArrow.left f)
</summary>
</member>
<member name="M:Marvel.AsyncArrow.choice``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Lifts the output of an arrow into a choice.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.right``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,``0})">
<summary>
 A mirror image of left.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.left``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Feed marked inputs through the argument arrow, passing the rest through unchanged to the output.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.fanin``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Split the input between the two argument arrows and merge their outputs.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.composeChoice``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``3,``2}}})">
<summary>
 Composes two arrows which return return a choice.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.sequenceArrayPar``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}}[])">
<summary>
 Creates an arrow which applies an array of arrows to an array of inputs in parallel. Both arrays must be of equal size.
 This follows from the fact that an array is a traversable and an arrow is an applicative.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.array``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0[])">
<summary>
 Lifts an arrow to operate on arrays of inputs, applying sequentially.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.arrayPar``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0[])">
<summary>
 Lifts an arrow to operate on arrays of inputs, applying in parallel but preserving input order.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.doBeforeAfter``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Creates an arrow which first calls the function g, then the arrow and then the function h with the output of an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.doBeforeAfterAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Creates an arrow which first calls the function g, then the arrow and then the function h with the output of an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.doBefore``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Runs an arrow after the target arrow.    
</summary>
</member>
<member name="M:Marvel.AsyncArrow.thenDo_``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Creates an arrow which first invokes f then g with the results of f. The results (but not side-effects) of g are discarded.
 (doAfter_ with arguments flipped).
</summary>
</member>
<member name="M:Marvel.AsyncArrow.doAfter_``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``0}},``2)">
<summary>
 Runs an arrow after the target arrow passing in the output of target arrow.
 (thenDo_ with arguments flipped).
</summary>
</member>
<member name="M:Marvel.AsyncArrow.thenDo``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Creates an arrow which first invokes f then g with the results of f. The results (but not side-effects) of g are discarded.
 (doAfter with arguments flipped).
</summary>
</member>
<member name="M:Marvel.AsyncArrow.doAfter``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Creates an arrow which first invokes f then g with the results of f. The results (but not side-effects) of g are discarded.
 (thenDo with arguments flipped).
</summary>
</member>
<member name="M:Marvel.AsyncArrow.filterAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Filters inputs to an arrow based on the specified predicate.
 Returnes the provided default value when the predicate isn&apos;t satisfied.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncArrow.ignoreAndThread``2">
<summary>
 Invokes the arrow, ignores its output and propagates its input into the output.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncArrow.some``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Lifts the output of an arrow into an option.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncArrow.option``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Feeds a Some a to the argument arrow, otherwise returns None.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.composeOption``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``2}}})">
<summary>
 Composes two arrows which return optional results.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.threadInput``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Creates an arrow which propagates its argument into the output.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.strength``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Creates an arrow which propagates its argument into the output.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.second``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``2,``0)">
<summary>
 Mirror of first.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.first``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0,``2)">
<summary>
 Creates an arrow which feeds the first argument to the argument arrow and passes the second one through.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.freeSecond``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Creates an arrow which ignores its second argument and otherwises uses the argument arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.freeFirst``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Creates an arrow which ignores its first argument and otherwises uses the argument arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.snd``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``1,``2}}})">
<summary>
 Projects the second item of the result tuple.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.fst``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``1,``2}}})">
<summary>
 Projects the first item of the result tuple.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.fanout``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Fans out the input to both arrows in parallel and collects the result.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.split``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``3}},``0,``2)">
<summary>
 Splits the input among provided arrows.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapInSndAsync``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Maps over the second element of an input pair.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapInSnd``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Maps over the second element of an input pair.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapInFstAsync``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Maps over the first element of an input pair.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapInFst``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Maps over the first element of an input pair.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapOutSndAsync``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Maps over the second element of an output pair.  
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapOutSnd``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Maps over the second element of an output pair.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapOutFstAsync``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Maps over the first element of an output pair.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapOutFst``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Maps over the first element of an output pair.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.dimapAsync``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``3}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Maps over both the input and the output of an arrow.
 Note: this makes the arrow a profunctor.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.dimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Maps over both the input and the output of an arrow.
 Note: this makes the arrow a profunctor.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapOutAsync``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Maps over the output of an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.maprAsync``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Maps over the output of an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapOut``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Maps over the output of an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapr``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Maps over the output of an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapInAsync``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Maps over the input to an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.maplAsync``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Maps f over the input to an arrow a. The arrow f is invoked before the arrow a.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapIn``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Maps over the input to an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.mapl``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Maps over the input to an arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.andThen``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Composes two arrows.
 (AsyncArrow.compose with arguments flipped).
</summary>
</member>
<member name="M:Marvel.AsyncArrow.compose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Composes two arrows.
 (AsyncArrow.andThen with arguments flipped).
</summary>
</member>
<member name="M:Marvel.AsyncArrow.app``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 An arrow which applies an input arrow to an argument.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.identity``1">
<summary>
 The identity arrow.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.arr``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Lifts a function into an arrow.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncArrow.Laws.fprod``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},``0,``2)">
<summary>
 The product functor.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.Laws.EQ``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Determines equality of two arrows.
</summary>
</member>
<member name="T:Marvel.AsyncArrow.Laws">

</member>
<member name="M:Marvel.AsyncArrow.Infixes.op_RightShift``3">
<summary>
 Composes two arrows.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.Infixes.op_BitwiseOr``3">
<summary>
 Split the input between the two argument arrows and merge their outputs.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.Infixes.op_BitwiseAnd``3">
<summary>
 Fans out the input to both arrows and collects the result.
</summary>
</member>
<member name="M:Marvel.AsyncArrow.Infixes.op_MultiplyMultiplyMultiply``4">
<summary>
 Splits the input among provided arrows.
</summary>
</member>
<member name="T:Marvel.AsyncArrow.Infixes">
<summary>
 Infix operators for arrows.
</summary>
</member>
<member name="T:Marvel.AsyncArrow">
<summary>
 Operations on async arrows.
</summary>
</member>
<member name="M:Marvel.AsyncCell.put``1(``0,Marvel.AsyncCell{``0})">
 <summary>
 Puts a value into a storage cell.
 </summary>
 <param name="a"></param>
 <param name="c"></param>
 <remarks>The central difference between this an AsyncCh.fill is that the latter will only complete when there is a matching reader.</remarks>
</member>
<member name="M:Marvel.AsyncCell.get``1(Marvel.AsyncCell{``0})">
<summary>
 Gets a value from a storage cell.
</summary>
</member>
<member name="M:Marvel.AsyncCell.create``1(``0)">
<summary>
 Creates an async storage cell initialized with the specified value.
</summary>
</member>
<member name="T:Marvel.AsyncCell">
<summary>
 Operations on async storage cells.
</summary>
</member>
<member name="M:Marvel.AsyncCh.enqueueFill``1(``0,Marvel.AsyncCh{``0})">
<summary>
 Creates an async computation which completes when the provided value is read from the channel. 
</summary>
</member>
<member name="M:Marvel.AsyncCh.fillNow``1(``0,Marvel.AsyncCh{``0})">
<summary>
 Starts an async computation which writes a value to a channel.
</summary>
</member>
<member name="M:Marvel.AsyncCh.fill``1(``0,Marvel.AsyncCh{``0})">
<summary>
 Creates an async computation which completes when the provided value is read from the channel. 
</summary>
</member>
<member name="M:Marvel.AsyncCh.takeNow``1(Marvel.AsyncCh{``0})">
<summary>
 Blocks until a value is available in the channel.
</summary>
</member>
<member name="M:Marvel.AsyncCh.take``1(Marvel.AsyncCh{``0})">
<summary>
 Creates an async computation which completes when a value is available in the channel.
</summary>
</member>
<member name="M:Marvel.AsyncCh.createFull``1(``0)">
<summary>
 Creates a channel initialized with a value.
</summary>
</member>
<member name="M:Marvel.AsyncCh.create``1">
<summary>
 Creates an empty channel.
</summary>
</member>
<member name="T:Marvel.AsyncCh">
<summary>
 Operations on channels.
</summary>
</member>
<member name="M:Marvel.AsyncCodec.dimapAsync``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``3}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``4,System.String}}},Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Maps over the input to the decoder and the output of the decoder.
</summary>
</member>
<member name="M:Marvel.AsyncCodec.decode``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``2}},Microsoft.FSharp.Core.FSharpFunc{``2,``1},``0)">
<summary>
 Decodes a value using a codec.
</summary>
</member>
<member name="M:Marvel.AsyncCodec.encode``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``2}},Microsoft.FSharp.Core.FSharpFunc{``2,``1},``2)">
<summary>
 Encodes a value using a codec.
</summary>
</member>
<member name="M:Marvel.AsyncCodec.ofCodec``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``2}},Microsoft.FSharp.Core.FSharpFunc{``2,``1})">
<summary>
 Creates an async codec from a codec.
</summary>
</member>
<member name="T:Marvel.AsyncCodec">
<summary>
 Operations on async codecs.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncExtensions.Async.choose.Static``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an async computation which completes when any of the argument computations completes. 
 The other argument computation is cancelled.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.chooseBothAny.Static``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Creates a computation which produces a tuple consiting of the value produces by the first
 argument computation to complete and a handle to the other computation. The second computation
 to complete is memoized.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.chooseBoth.Static``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates a computation which returns the result of the first computation that
 produces a value as well as a handle to the other computation. The other
 computation will be memoized.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.memoize.Static``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Cache a function&apos;s async result for each argument to reduce expensive and repetitive
 computation of an asynchronous operation. Uses a concurrent dictionary for backing
 storage, and at-least-once invocation semantics per key.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.cache.Static``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Caches a computation such that it is only invoked once.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.throw.Static``1(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``0,System.Exception}})">
<summary>
 The opposite of Async.Catch - will raise an erroneous result as an exception.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.strength.Static``2(Microsoft.FSharp.Control.FSharpAsync{``0},``1)">
 <summary>
 Takes a value and an async computation and creates an async computation which includes the original result and the value.
 </summary>
 <param name="a"></param>
 <param name="b"></param>
 <remarks>http://en.wikipedia.org/wiki/Strong_monad</remarks>
</member>
<member name="M:Marvel.AsyncExtensions.Async.serialize.Static``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Ensures that the function is invoked serially - no overlapping calls.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncExtensions.Async.bindOpt.Static``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Async/Option transformer bind.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.mapOpt.Static``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Async/Option transformer map.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncExtensions.Async.StartDisposable.Static(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts the specified operation using a new CancellationToken and returns
 IDisposable object that cancels the computation. This method can be used
 when implementing the Subscribe method of IObservable interface.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.retryAll.Static``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Retries an async computation given any exception.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.retry.Static``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Exception,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Retries an async computation when exceptions match the specified filter.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.retryTimeout.Static``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Exception,System.Boolean},System.Int32,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Retries an async computation.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.retryAllBackoff.Static``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Retries an async computation.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.retryBackoff.Static``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Exception,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Retries an async computation.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.toSync.Static``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Given a function returning an async computation, return a unit returning function (sink) which
 executes the async function internally through a blocking buffer.            
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.toSyncStop.Static``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Given a function returning an async computation, return a unit returning function (sink) which
 executes the async function internally through a blocking buffer.            
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.ParallelThrottled.Static``1(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Creates an async computation which runs the provided sequence of computations and completes
 when all computations in the sequence complete. Up to parallelism computations will
 be in-flight at any given point in time. Error or cancellation of any computation in
 the sequence causes the resulting computation to error or cancel, respectively.
 Like Async.Parallel but with support for throttling.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.ParallelIgnore.Static``1(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Creates an async computation which runs the provided sequence of computations and completes
 when all computations in the sequence complete. Up to parallelism computations will
 be in-flight at any given point in time. Error or cancellation of any computation in
 the sequence causes the resulting computation to error or cancel, respectively.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.withParallelWorkersUnbounded.Static(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates a computation which executes the specified computations sinks in parallel with unbounded parallelism. 
 Note: almost always you want to run the throttled variant because if the computations are being produced faster
 than they complete, OOM is imminent.
</summary>
</member>
<member name="M:Marvel.AsyncExtensions.Async.withParallelWorkers.Static(System.Int32,System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
 <summary>
 Creates a computation which executes the specified computations sinks in parallel with the specified degree of parallelism. 
 This is a memory conserving alternative to Async.Parallel for when the computations are sinks such that the results can be discarded.
 </summary>
 <remarks>
 There are several notable guarantees provided by this scheduler. The sequence of input computations will be 
 iterated in sequential order and each computation will be started on the calling thread. The computation will
 execute on the calling thread until it reaches an async boundary at which point the Async trampoline takes over.
 These guarantees are important for consumers which require ordering guarantees.
 Note, this will be inefficient for CPU bound tasks, since the initial part of each computation will be run on a single thread and subsequent computations will have to wait.
 </remarks>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncExtensions.Async.get_empty.Static">
<summary>
 An async computation which does nothing.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncExtensions.AsyncOps">

</member>
<member name="T:Marvel.AsyncExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncFilter">
<summary>
 Operations on async filters.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncIoChan">
<summary>
 Operations on input/output channels.
</summary>
</member>
<member name="M:Marvel.AsyncLaws.associativity``3(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Monadic associative law - binding a computation to f and binding to result to g is the same as binding a computation to a function which applies f to the underlying value followed by a bind to g.
 In other words, binding first to f then to g is the same as binding to the result of composing f and g.
</summary>
</member>
<member name="M:Marvel.AsyncLaws.rightUnit``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Moandic right unit - binding an Async computation to a function which returns the underlying value leaves it unchanged.
</summary>
</member>
<member name="M:Marvel.AsyncLaws.leftUnit``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Monadic left unit - lifting a value into Async and binding to a function f is equivalent to applying f to the value.
</summary>
</member>
<member name="M:Marvel.AsyncLaws.composition``3(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Functor composition - composing functions outside of the functor is the same as composting them through the functor.
</summary>
</member>
<member name="M:Marvel.AsyncLaws.identity``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Functor identity - mapping the identity function over an async computation leaves it unchaged.
</summary>
</member>
<member name="M:Marvel.AsyncLaws.EQ``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Witness equality between two async computations.
</summary>
</member>
<member name="T:Marvel.AsyncLaws">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncObservable.ofAsyncSeq``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates an observable from an async sequence such that each observer will iterate through the sequence using the specified degree of concurrency.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncObservable.withObserverPreEffect``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates an observable which invokes the specified effect before each observation.
</summary>
</member>
<member name="M:Marvel.AsyncObservable.withObserverPostEffect``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates an observable which invokes the specified effect after each observation.
</summary>
</member>
<member name="M:Marvel.AsyncObservable.withObserver``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates an observable which wraps observers.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncObservable.merge``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates an observable which adds observers to the two underlying observables.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncObservable.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates an async channel which schedulers observers in parallel.
</summary>
</member>
<member name="M:Marvel.AsyncObservable.subjectSeq``1">
<summary>
 Creates an async channel consisting of an observer (input) and corresponding observable (output) which executes observer effects sequentially.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncObservable.subject``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}})">
<summary>
 Creates an async channel consisting of an observer (input) and corresponding observable (output).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncObservable">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncObservableOps">

</member>
<member name="M:Marvel.AsyncObserver.monoid``1">
<summary>
 Async observer monoid.
</summary>
</member>
<member name="M:Marvel.AsyncObserver.merge``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Merges two observables into one such that one is invoked sequentially after the other.
</summary>
</member>
<member name="M:Marvel.AsyncObserver.toSync``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates a syncrhonous observer which schedules notifcations to a woker queue.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncObserver">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncParSeq">

</member>
<member name="M:Marvel.AsyncPipe.compose``4(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncPipeStep{``0,``1,``2}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncPipeStep{``1,``3,``2}})">
<summary>
 Fuses two pipes together. 
 When the second pipe is done, the resulting pipe is done.
 When the second pipe emits, the resulting pipe emits. 
 When the second pipe awaits, the first pipe is invoked to see if it emits, in which case it emits into the second pipe.
 If the first pipe awaits, then the resulting pipe awaits.
</summary>
</member>
<member name="M:Marvel.AsyncPipe.bufferByCount``1(System.Int32)">
<summary>
 Creates an async pipeline which buffers its inputs by count and emits buffers.
</summary>
</member>
<member name="M:Marvel.AsyncPipe.repeat``3(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncPipeStep{``0,``1,``2}})">
<summary>
 Repeats an async pipe indefinitely - when it reaches the end it starts the process over.
</summary>
</member>
<member name="M:Marvel.AsyncPipe.mapOut``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncPipeStep{``2,``0,``3}})">
<summary>
 Maps over the output of an async pipe.
</summary>
</member>
<member name="M:Marvel.AsyncPipe.mapIn``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncPipeStep{``1,``2,``3}})">
<summary>
 Maps over the input to an async pipe.        
</summary>
</member>
<member name="M:Marvel.AsyncPipe.awaitDoneWith``3(``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncPipeStep{``1,``2,``0}}})">
<summary>
 Creates an async pipe which awaits input.
</summary>
</member>
<member name="M:Marvel.AsyncPipe.await``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncPipeStep{``0,``1,``2}}})">
<summary>
 Creates an async pipe which awaits input and continues. An absence of input is indicated by None.
</summary>
</member>
<member name="M:Marvel.AsyncPipe.emitDone``3(``0,``1)">
<summary>
 Creates an async pipe which emits a value and then stops immediately with the specified value.
</summary>
</member>
<member name="M:Marvel.AsyncPipe.emit``3(``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncPipeStep{``1,``0,``2}})">
<summary>
 Creates an async pipe which emits a value followed by the specified remainder.
</summary>
</member>
<member name="M:Marvel.AsyncPipe.doneWith``3(``0)">
<summary>
 Creates an async pipe which halts immediately with the specified value.
</summary>
</member>
<member name="T:Marvel.AsyncPipe">
<summary>
 Operations on async pipes.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncProc.readAhead``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Modifies an async sequence such that upon iteration, the next value is retrieved right away.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncProc.run(Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Runs an async process for its side-effects.
</summary>
</member>
<member name="M:Marvel.AsyncProc.runSource``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{Microsoft.FSharp.Core.Unit,``0}})">
<summary>
 Drains a source into an async sink.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncProc.ofAsyncSeq``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Converts an async sequence into a source process.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncProc.count``1">
<summary>
 A process which emits a running count of the number of inputs received.
</summary>
</member>
<member name="M:Marvel.AsyncProc.loop``3(``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,``0},System.Tuple{``2,``0}})">
<summary>
 Creates a process based on a stateful loop given an initial state.
 The process repeatedly applies the function f to its input, emits the result as output and continues with the next state.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncProc.op_BarTwiddleGreater``3(Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``1,``2}})">
<summary>
 Fuses two processes together creating a pipeline.
</summary>
</member>
<member name="M:Marvel.AsyncProc.pipe``3(Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``1,``2}})">
<summary>
 Fuses two processes together creating a pipeline.
</summary>
</member>
<member name="M:Marvel.AsyncProc.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
<summary>
 Creates a process which filters inputs.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncProc.sink``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Creates a sink process based on the specified async sink.
</summary>
</member>
<member name="M:Marvel.AsyncProc.liftAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Creates a process which repeatedly transforms input using the specified async function.
</summary>
</member>
<member name="M:Marvel.AsyncProc.liftAsyncOne``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Creates a process which transforms input using the specified async function once then stops.
</summary>
</member>
<member name="M:Marvel.AsyncProc.id``1">
<summary>
 The identity process repeatedly echoes its input.
</summary>
</member>
<member name="M:Marvel.AsyncProc.lift``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a repeated process which transforms input based on a function.
</summary>
</member>
<member name="M:Marvel.AsyncProc.liftOne``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a process which transforms a single input based on a function and then stops.
</summary>
</member>
<member name="M:Marvel.AsyncProc.echo``1">
<summary>
 Creates a process which echoes its input.
</summary>
</member>
<member name="M:Marvel.AsyncProc.repeated``1(``0)">
<summary>
 Repeatedly emits the specified value as output.
</summary>
</member>
<member name="M:Marvel.AsyncProc.repeat``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}})">
<summary>
 Repeats a proccess indefinitely - when it reaches the end it starts the process over.
</summary>
</member>
<member name="M:Marvel.AsyncProc.applyAsyncSeq``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}})">
<summary>
 Applies a process to an async sequence producing output as an async sequence.
</summary>
</member>
<member name="M:Marvel.AsyncProc.feedAsyncSeq``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}})">
<summary>
 Feeds an async sequence into a process resulting in a composite process.
</summary>
</member>
<member name="M:Marvel.AsyncProc.feed``2(``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}})">
<summary>
 Creates a process which feeds a value into a process and continues.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncProc.append``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}})">
<summary>
 Creates a process which runs the first process to completion, then the second.
</summary>
</member>
<member name="M:Marvel.AsyncProc.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``2,``0}})">
<summary>
 Maps over the output of a process.
</summary>
</member>
<member name="M:Marvel.AsyncProc.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}}})">
<summary>
 Strict to lazy.
</summary>
</member>
<member name="M:Marvel.AsyncProc.awaitStop``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}}})">
<summary>
 Creates an awaiting process which stops if no input is provided.
</summary>
</member>
<member name="M:Marvel.AsyncProc.await``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}}})">
<summary>
 Creates a process whith an awaiter accepting potentially empty input.
</summary>
</member>
<member name="M:Marvel.AsyncProc.awaitFB``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}}},Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``0,``1}})">
<summary>
 Creates an awaiting process with a fallback to run if no input is provided.
</summary>
</member>
<member name="M:Marvel.AsyncProc.emitOne``2(``0)">
<summary>
 Creates a process which emits one value then stops.
</summary>
</member>
<member name="M:Marvel.AsyncProc.emit``2(``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.Step{``1,``0}})">
<summary>
 Creates a process which emits a value followed by another process.
</summary>
</member>
<member name="M:Marvel.AsyncProc.stop``2">
<summary>
 Creates a stopped process.
</summary>
</member>
<member name="T:Marvel.AsyncProc">
<summary>
 Async process combinators.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncReactor">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncSeq.EagerSeq`1">
<summary>
 Converts a sequence of bytes to a read-only Stream which supports Stream.ReadAsync.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncSeq.AsyncSeqBuilder.For``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}}})">
<summary>
 Asynchronous for loop - for all elements from the input sequence,
 generate all elements produced by the body (asynchronously). See
 also the AsyncSeq.collect function.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.AsyncSeqBuilder.For``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}}})">
<summary>
 For loop that iterates over a synchronous sequence (and generates
 all elements generated by the asynchronous body)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncSeq.AsyncSeqBuilder">
<summary>
 Computation builder that allows creating of asynchronous 
 sequences using the &apos;asyncSeq { ... }&apos; syntax
</summary>
</member>
<member name="M:Marvel.AsyncSeq.iterAsyncPartitionBy``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Iterates the async sequence such that its elements are grouped using the specified grouping function and elements
 within a group are processed serially but processing across groups is parallelised with a specified degree of parallelism.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.groupByLinger``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Groups elements of an async sequence using the specified key function such that
 when a sub-sequence is iterated, an attempt is made to close the group after each item is processed after a specified linger period
 which can potentially allow more items to arrive.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.groupByClose``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Groups elements of an async sequence using the specified key function such that
 when a sub-sequence is iterated, an attempt is made to close the group after each item is processed.
 If during processing more items belonging to the group arrive, the group remains open.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.groupByAsync``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{``2}}}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Groups elements of an async sequence using the specified key function to identify groups and a group constructor function
 which given the grouping key, a computation which when activated closes the group and an async sequence representing the sub-sequence
 corresponding to the key, create a group. Groups are closed only when the close computation is activated, otherwise behaving
 like Seq.groupBy. If a group is closed, it may re-appear later when more elements mapped to the grouping key arrive.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncSeq.toIoStream``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Byte[]},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Converts an async sequence to a System.IO.Stream by converting each element to a byte array.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.withPreEffect``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Modifies an async sequence such that a specified effect is invoked before each element is yielded.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.withEffect``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Modifies an async sequence such that a specified effect is invoked after each element is yielded and consumed.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.ofAsyncCh``1(Marvel.AsyncCh{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Creates an async computation from a channel which reads values from the channel until None is returned.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.mergeAll``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}}})">
<summary>
 Merges all specified async sequences into an async sequence non-deterministically.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.merge``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Merges two async sequences into an async sequence non-deterministically.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.seqOfAsyncToArray``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Iterates a sequnce of async computations and collects their results into an array.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.toList``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Iterates the AsyncSeq and collects the output into a list.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.toArray``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Iterates the AsyncSeq and collects the output into an array.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.unfoldAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}}},``0)">
<summary>
 Generates an async sequence using the specified generator function.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.concatSeq``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Flattens an AsyncSeq of sequences.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.collectSeq``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Flattens a projection of AsyncSeq to sequences.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.iterAsyncParBatch``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}})">
<summary>
 Iterates the AsyncSeq, starting each computation concurrently on the current thread, with a specified degree of parallelism.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.iterAsyncParThrottled``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Iterates the AsyncSeq, starting each computation concurrently on the current thread, with a specified degree of parallelism.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.iterAsyncPar``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Iterates the AsyncSeq, starting each computation concurrently on the current thread.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncSeq.mergeFair``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Interleaves two async sequences yielding when either sequences yields instead of lockstep.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncSeq.skip``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Skips the first N elements of an asynchronous sequence and
 then returns the rest of the sequence unmodified.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.take``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Returns the first N elements of an asynchronous sequence
</summary>
</member>
<member name="M:Marvel.AsyncSeq.skipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Skips elements from an asynchronous sequence while the specified 
 predicate holds and then returns the rest of the sequence. The 
 predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.takeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Returns elements from an asynchronous sequence while the specified 
 predicate holds. The predicate is evaluated synchronously.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.skipWhileAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Skips elements from an asynchronous sequence while the specified 
 predicate holds and then returns the rest of the sequence. The 
 predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.takeWhileAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Returns elements from an asynchronous sequence while the specified 
 predicate holds. The predicate is evaluated asynchronously.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.zip``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}})">
<summary>
 Combines two asynchronous sequences into a sequence of pairs. 
 The values from sequences are retrieved in parallel. 
</summary>
</member>
<member name="M:Marvel.AsyncSeq.readAhead``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Modifies an async sequence such that it reads ahead into a bounded buffer.
 When the buffer reaches capacity, it blocks reads of the source sequence.
 This is useful for decoupling producers from consumers.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.toBlockingSeq``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Converts an AsyncSeq into a blocking sequence. 
 Disposal of the resulting sequence causes iteration to stop.
 Exceptions raised during iteration are propagated.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.toBlockingSeqBufferedMap``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Creates a blocking sequence using a buffer.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.toObservable``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Converts asynchronous sequence to an IObservable&lt;_&gt;. When the client subscribes
 to the observable, a new copy of asynchronous sequence is started and is 
 sequentially iterated over (at the maximal possible speed). Disposing of the 
 observer cancels the iteration over asynchronous sequence. 
</summary>
</member>
<member name="M:Marvel.AsyncSeq.ofObservableWithBlockingQueueStop``1(System.Int32,System.IObservable{``0})">
<summary>
 Creates an async sequence from an observable, buffering incoming events in a blocking queue.
 Signals buffer completion upon error and throws exceptions on calling thread.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.bufferByTimeAndCount``1(System.Int32,System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Buffers an async sequence by waiting for a the buffer to reach a certain size or for a specific 
 amount of time to pass.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.bufferByCount``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Buffer items from the async sequence into buffers of a specified size.
 The last buffer returned may be less than the specified buffer size.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an asynchronous sequence that lazily takes element from an
 input synchronous sequence and returns them one-by-one.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.filterAsync, but the specified predicate is synchronous
 and processes the input element immediately.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.chooseAsync, but the specified function is synchronous
 and processes the input element immediately.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.iterAsync, but the specified function is synchronous
 and performs the side-effect immediately.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Same as AsyncSeq.mapAsync, but the specified function is synchronous
 and returns the result of projection immediately.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}})">
<summary>
 Same as AsyncSeq.scanAsync, but the specified function is synchronous
 and returns the result of aggregation immediately.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.existsAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Determines if an element satisfying the specified predicate exists in the async sequence.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.tryPickAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Applies the specified function to successive elements returning the first returning Some.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.foldAsyncT``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}}},``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}})">
<summary>
 Like AsyncSeq.foldAsync but with a possibility of early termination.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}})">
<summary>
 Same as AsyncSeq.foldAsync, but the specified function is synchronous
 and returns the result of aggregation immediately.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.foldAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}})">
<summary>
 Aggregates the elements of the input asynchronous sequence using the
 specified &apos;aggregation&apos; function. The result is an asynchronous 
 workflow that returns the final result.

 The aggregation function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:Marvel.AsyncSeq.pairwise``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Returns an asynchronous sequence that returns pairs containing an element
 from the input sequence and its predecessor. Empty sequence is returned for
 singleton input sequence.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.iterAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Iterates over the input sequence and calls the specified function for
 every value (to perform some side-effect asynchronously).

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:Marvel.AsyncSeq.scanAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``0}}},``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}})">
<summary>
 Aggregates the elements of the input asynchronous sequence using the
 specified &apos;aggregation&apos; function. The result is an asynchronous 
 sequence of intermediate aggregation result.

 The aggregation function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:Marvel.AsyncSeq.firstOrDefault``1(``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Asynchronously returns the first element that was generated by the
 given asynchronous sequence (or the specified default value).
</summary>
</member>
<member name="M:Marvel.AsyncSeq.lastOrDefault``1(``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Asynchronously returns the last element that was generated by the
 given asynchronous sequence (or the specified default value).
</summary>
</member>
<member name="M:Marvel.AsyncSeq.filterAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Builds a new asynchronous sequence whose elements are those from the
 input sequence for which the specified function returned true.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:Marvel.AsyncSeq.chooseAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Asynchronously iterates over the input sequence and generates &apos;x&apos; for 
 every input element for which the specified asynchronous function 
 returned &apos;Some(x)&apos; 

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="M:Marvel.AsyncSeq.mapAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Builds a new asynchronous sequence whose elements are generated by 
 applying the specified function to all elements of the input sequence.

 The specified function is asynchronous (and the input sequence will
 be asked for the next element after the processing of an element completes).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.AsyncSeq.collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``1}}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Creates an asynchronou sequence that iterates over the given input sequence.
 For every input element, it calls the the specified function and iterates
 over all elements generated by that asynchronous sequence.
 This is the &apos;bind&apos; operation of the computation expression (exposed using
 the &apos;for&apos; keyword in asyncSeq computation).
</summary>
</member>
<member name="M:Marvel.AsyncSeq.tryFinally``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements the &apos;TryFinally&apos; functionality for computation builder
</summary>
</member>
<member name="M:Marvel.AsyncSeq.tryWith``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}}})">
<summary>
 Implements the &apos;TryWith&apos; functionality for computation builder
</summary>
</member>
<member name="M:Marvel.AsyncSeq.tryNext``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Tries to get the next element of an asynchronous sequence
 and returns either the value or an exception
</summary>
</member>
<member name="P:Marvel.AsyncSeq.asyncSeq">
<summary>
 Builds an asynchronou sequence using the computation builder syntax
</summary>
</member>
<member name="M:Marvel.AsyncSeq.append``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}})">
<summary>
 Yields all elements of the first asynchronous sequence and then 
 all elements of the second asynchronous sequence.
</summary>
</member>
<member name="M:Marvel.AsyncSeq.singleton``1(``0)">
<summary>
 Creates an asynchronous sequence that generates a single element and then ends
</summary>
</member>
<member name="M:Marvel.AsyncSeq.empty``1">
<summary>
 Creates an empty asynchronou sequence that immediately ends
</summary>
</member>
<member name="T:Marvel.AsyncSeq">
<summary>
 Module with helper functions for working with asynchronous sequences
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Marvel.AsyncSeqExtensions.asyncSeq">
<summary>
 Builds an asynchronou sequence using the computation builder syntax
</summary>
</member>
<member name="T:Marvel.AsyncSeqExtensions">

</member>
<member name="M:Marvel.AsyncSink.catchLog``1(NLog.Logger)">
<summary>
 Catches errors raised by the AsyncSink and logs them in the provided logger without rethrowing.
</summary>
</member>
<member name="M:Marvel.AsyncSink.catchNotify``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Exception},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},``0)">
<summary>
 Catches errors raised by the AsyncSink and sends them to the provided callback without rethrowing.
</summary>
</member>
<member name="M:Marvel.AsyncSink.liftSeqS``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Lifts an async sink to operate on sequences of the input type in sequence.
</summary>
</member>
<member name="M:Marvel.AsyncSink.liftSeq``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Lifts an async sink to operate on sequences of the input type in parallel.        
 TODO: rename to liftSeqCon
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.AsyncSink.mergePar``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Merges two sinks such that the resulting sink invokes the first one, then the second one.
</summary>
</member>
<member name="M:Marvel.AsyncSink.mergeAllPar``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},``0)">
<summary>
 Creates a sink which invokes the underlying sinks in parallel.
</summary>
</member>
<member name="M:Marvel.AsyncSink.mergeAll``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},``0)">
<summary>
 Creates a sink which invokes the underlying sinks sequentially.
</summary>
</member>
<member name="M:Marvel.AsyncSink.merge``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},``0)">
<summary>
 Merges two sinks such that the resulting sink invokes the first one, then the second one.
</summary>
</member>
<member name="M:Marvel.AsyncSink.contramap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Maps a function over the sink.
</summary>
</member>
<member name="T:Marvel.AsyncSink">
<summary>
 An async sink: &apos;a -&gt; Async&lt;unit&gt;
</summary>
</member>
<member name="M:Marvel.AsyncStream.mergeAll``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}}})">
<summary>
 Merges a list of streams.
</summary>
</member>
<member name="M:Marvel.AsyncStream.merge``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Merges two streams such that the resutling streams will consume elements from either stream
 non-deterministically.
</summary>
</member>
<member name="M:Marvel.AsyncStream.distributeList``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}}})">
<summary>
 Takes a list of streams and produces a stream of lists.
</summary>
</member>
<member name="M:Marvel.AsyncStream.iterAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Creates a computation which applies the function f to elements of the stream forever.
</summary>
</member>
<member name="M:Marvel.AsyncStream.unzip``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{System.Tuple{``0,``1}}})">
<summary>
 Unzips a stream of pairs into a pair of streams.
 The current implementation will start reading the stream into channels which are then
 consumed by the resulting streams.
</summary>
</member>
<member name="M:Marvel.AsyncStream.ofAsyncCh``1(Marvel.AsyncCh{``0})">
<summary>
 Creates a stream which continuously reads from an async channel.
</summary>
</member>
<member name="M:Marvel.AsyncStream.zipWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``1}})">
<summary>
 Zips two streams using the specified function.
</summary>
</member>
<member name="M:Marvel.AsyncStream.zip``2(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``1}})">
<summary>
 Zips two streams into a stream of pairs.
</summary>
</member>
<member name="M:Marvel.AsyncStream.scanAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``1}}},``1,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Scans the stream applying the specified function to consecutive elements and
 returning the stream of results. 
</summary>
</member>
<member name="M:Marvel.AsyncStream.chooseAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Filters and maps a stream using the specified choose function.
</summary>
</member>
<member name="M:Marvel.AsyncStream.filterAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Filters a stream based on the specified predicate.
</summary>
</member>
<member name="M:Marvel.AsyncStream.splitAtList``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Returns a pair consisting of the prefix of the stream of the specified length
 and the remaining stream immediately following this prefix.
</summary>
</member>
<member name="M:Marvel.AsyncStream.drop``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Drops the first n items from the stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.takeWhileAsync``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Takes elements from the stream until the specified predicate is no longer satisfied.
</summary>
</member>
<member name="M:Marvel.AsyncStream.take``1(System.Int32,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Creates an async sequence which iterates through the first n elements from the stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.toAsyncSeq``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Creates an infinite async sequence from the stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.mapAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Maps a function over an async stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.tails``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Creates a stream of tails of the specified stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.tail``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Creates a stream which skips the first element of the provided stream.       
</summary>
</member>
<member name="M:Marvel.AsyncStream.head``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Returns the first element of the stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
<summary>
 Produces the infinite sequence of repeated applications of f.
</summary>
</member>
<member name="M:Marvel.AsyncStream.prefixAsyncSeq``1(Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncSeqInner{``0}},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Prepends an async sequence to a stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.prefixList``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Prepends a list to a stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.cycleList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns infinite repetition of the specified list.
</summary>
</member>
<member name="M:Marvel.AsyncStream.unfoldAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Tuple{``1,``0}}},``0)">
<summary>
 Generates an async stream.
</summary>
</member>
<member name="M:Marvel.AsyncStream.repeat``1(``0)">
<summary>
 Creates an async stream which repeatedly returns the provided value.
</summary>
</member>
<member name="M:Marvel.AsyncStream.create``1(``0,Microsoft.FSharp.Control.FSharpAsync{Marvel.AsyncStreamNode{``0}})">
<summary>
 Creates an async stream given a head and tail.
</summary>
</member>
<member name="T:Marvel.AsyncStream">
<summary>
 Operations on async streams.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.AsyncStreamNode">

</member>
<member name="P:Marvel.Backoff.DefaultExponentialBoundedRandomized">
<summary>
 The default exponential and randomized back-off strategy.
 DefaultInitialIntervalMs = 500
 DefaultMaxIntervalMs = 60,000
 DefaultRandomizationFactor = 0.5
 DefaultMultiplier = 1.5
</summary>
</member>
<member name="M:Marvel.Backoff.state(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}})">
<summary>
 Creates a stateful back-off strategy which keeps track of the number of attempts.
</summary>
</member>
<member name="M:Marvel.Backoff.fib(System.Int32)">
<summary>
 Uses a fibonacci sequence to genereate timeout intervals starting from the specified initial interval.
</summary>
</member>
<member name="M:Marvel.Backoff.rand(System.Double)">
<summary>
 Randomizes the output produced by a back-off strategy:
 randomizedInterval = retryInterval * (random in range [1 - randomizationFactor, 1 + randomizationFactor])
</summary>
</member>
<member name="M:Marvel.Backoff.exp(System.Int32,System.Double,System.Int32)">
<summary>
 Creates a back-off strategy which increases the interval exponentially.
</summary>
</member>
<member name="M:Marvel.Backoff.bound(System.Int32)">
<summary>
 Bounds the interval.
</summary>
</member>
<member name="M:Marvel.Backoff.map(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}},System.Int32)">
<summary>
 Modifies the interval.
</summary>
</member>
<member name="M:Marvel.Backoff.bind(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32}},System.Int32)">
<summary>
 Modifies the interval.
</summary>
</member>
<member name="M:Marvel.Backoff.linear(System.Int32)">
<summary>
 Always returns a fixed interval.
</summary>
</member>
<member name="P:Marvel.Backoff.never">
<summary>
 Stops immediately.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Backoff">
<summary>
 Operations on back off strategies represented as functions (int -&gt; int option)
 which take an attempt number and produce an interval.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Boolean">

</member>
<member name="M:Marvel.ByteCodec.decFromBytesT``1(System.Byte[])">
<summary>
 Decodes a value from a byte array using a ByteCodec provided by a static member on the decoded type.
</summary>
</member>
<member name="M:Marvel.ByteCodec.encToBytesT``1(``0)">
<summary>
 Encodes a value to a byte array using a ByteCodec provided by a static member on the encoded type.
</summary>
</member>
<member name="T:Marvel.ByteCodec">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Choice.mergeErrs(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,System.String},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.Unit,System.String})">
<summary>
 Merges two choices which can potentially contain errors.
 When both choice values are errors, they are concatenated using &apos;;&apos;.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Choice.toOption``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Return Some v if either is Success v. Otherwise return None.
</summary>
</member>
<member name="M:Marvel.Choice.tryWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 evaluate f () and return either the result of the evaluation or the exception
</summary>
</member>
<member name="M:Marvel.Choice.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Binds a function to a choice where the right case represents failure to be propagated.
</summary>
</member>
<member name="M:Marvel.Choice.codiag``1">
<summary>
 Extracts the value from a choice with the same type on the left as the right.
 (Also known as the codiagonal morphism).
</summary>
</member>
<member name="M:Marvel.Choice.fold``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Folds a choice pair with functions for each case.
</summary>
</member>
<member name="M:Marvel.Choice.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps over the left or the right result type.
</summary>
</member>
<member name="M:Marvel.Choice.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps over the left result type.
</summary>
</member>
<member name="M:Marvel.Choice.mapr``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``0})">
<summary>
 Maps over the right result type.
</summary>
</member>
<member name="M:Marvel.Choice.mapl``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps over the left result type.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.Choice">

</member>
<member name="">

</member>
<member name="T:Marvel.ChoiceEx">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.CoState.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
<summary>
 Maps over the context.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.CoState.set``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Extracts the costate function - set.
</summary>
</member>
<member name="M:Marvel.CoState.seek``2(``0,``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Assigns the state in focus.
</summary>
</member>
<member name="M:Marvel.CoState.peek``2(``0,``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Applies the costate function to the specified state.
</summary>
</member>
<member name="M:Marvel.CoState.pos``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Gets the current position.
</summary>
</member>
<member name="M:Marvel.CoState.extract``1(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 Extracts the context under focus.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.CoState">

</member>
<member name="M:Marvel.Codec.stringToByteUTF8``1(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,System.String})">
<summary>
 Converts a string codec to a byte codec using UTF8.
</summary>
</member>
<member name="M:Marvel.Codec.byteToStringUTF8``1(Microsoft.FSharp.Core.FSharpFunc{System.Byte[],Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,System.Byte[]})">
<summary>
 Converts a byte codec to a string codec using UTF8.
</summary>
</member>
<member name="M:Marvel.Codec.dimap``5(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``4}},Microsoft.FSharp.Core.FSharpFunc{``4,``2})">
<summary>
 Maps over the input to the decoder and the output of the decoder.
</summary>
</member>
<member name="M:Marvel.Codec.mapDec``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``3}},Microsoft.FSharp.Core.FSharpFunc{``3,``2})">
<summary>
 Maps over the input to the decoder.
</summary>
</member>
<member name="M:Marvel.Codec.mapEnc``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpOption{``3}},Microsoft.FSharp.Core.FSharpFunc{``3,``0})">
<summary>
 Maps over the encoded value.
</summary>
</member>
<member name="M:Marvel.Codec.decodeAll``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},``0)">
<summary>
 Creates a decoder based on a set of decoders picking the result of the first
 to produce a value.
</summary>
</member>
<member name="M:Marvel.Codec.decode``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``2}},Microsoft.FSharp.Core.FSharpFunc{``2,``1},``0)">
<summary>
 Decodes a value using a codec.
</summary>
</member>
<member name="M:Marvel.Codec.encode``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``2}},Microsoft.FSharp.Core.FSharpFunc{``2,``1},``2)">
<summary>
 Encodes a value using a codec.
</summary>
</member>
<member name="T:Marvel.Codec">
<summary>
 Operations on codecs.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.Comparer">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.ConsoleHelpers">

</member>
<member name="M:Marvel.ConsoleProgram.initWithSource``1(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Collections.FSharpMap{System.String,System.String}},System.Boolean,System.String)">
<summary>
 Initialize a console program in a canonical fashion.
</summary>
</member>
<member name="M:Marvel.ConsoleProgram.init``1(System.Boolean,System.String)">
<summary>
 Initialize a console program in a canonical fashion.
</summary>
</member>
<member name="M:Marvel.ConsoleProgram.init4``1(System.Boolean,System.String,Microsoft.FSharp.Core.FSharpOption{NLog.LogLevel},Microsoft.FSharp.Core.FSharpOption{NLog.LogLevel})">
<summary>
 Initialize a console program in a canonical fashion, also providing log level overrides.
</summary>
</member>
<member name="M:Marvel.ConsoleProgram.init4WithSource``1(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Collections.FSharpMap{System.String,System.String}},System.Boolean,System.String,Microsoft.FSharp.Core.FSharpOption{NLog.LogLevel},Microsoft.FSharp.Core.FSharpOption{NLog.LogLevel})">
<summary>
 Initialize a console program in a canonical fashion, also providing arg source and log level overrides.
</summary>
</member>
<member name="T:Marvel.ConsoleProgram">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.ConsoleProgramModule.ConsoleProgramArgs">
<summary>
 Arguments value for a console application.
 NOTE: This is a class type due to the need for extensibility coupled with Marvel.Args
 requiring extensibility via the use of inheritance rather than composition.
</summary>
</member>
<member name="T:Marvel.ConsoleProgramModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Constants">

</member>
<member name="">

</member>
<member name="T:Marvel.Continuation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.DList">
<summary>
 Difference list.
</summary>
</member>
<member name="T:Marvel.Data.SqlRow">
<summary>
 A SQL table row represented as an array of columns and values.
</summary>
</member>
<member name="T:Marvel.Data.SqlColData">
<summary>
 A SQL table column represented as a name and value.
</summary>
</member>
<member name="T:Marvel.Data.DataMapping`1">
<summary>
 A mapping from a property on an object to a data field.
</summary>
</member>
<member name="M:Marvel.Data.DataMappings.toMergeSQL``1(System.String[],System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object}}},``0)">
<summary>
 Create a merge sql statement for given DataMapping sequence, table name and matching key field
</summary>
</member>
<member name="M:Marvel.Data.DataMappings.toMergeSqlDelta``1(System.String[],System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{System.String}},System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object}}},``0)">
<summary>
 Create a merge sql statement for given DataMapping sequence, table name and matching key field.
</summary>
</member>
<member name="M:Marvel.Data.DataMappings.union``2(System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object}}},System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``1,System.Object}}})">
<summary>
 Builds a DataMapping[] for a type which is the union of the specified mappings.
</summary>
</member>
<member name="M:Marvel.Data.DataMappings.merge``2(System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object}}},System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``1,System.Object}}})">
<summary>
 Builds a new DataMapping[] that contains the elements of each of the given DataMapping sequences.
</summary>
</member>
<member name="M:Marvel.Data.DataMappings.contramap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``1,System.Object}}})">
<summary>
 Applies contramap function for each element of given DataMapping sequence.
</summary>
</member>
<member name="M:Marvel.Data.DataMappings.columns``1(System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object}}})">
<summary>
 Gets the list of column names from the set of mappings.
</summary>
</member>
<member name="T:Marvel.Data.DataMappings">

</member>
<member name="M:Marvel.Data.SQL.mergeSQL(System.String,Microsoft.FSharp.Collections.FSharpList{System.String},System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Object}})">
 <summary>
 Generates a SQL MERGE statement based on a set of deltas consisting of changed column-value pairs.
 If there are no changes, then an empty string is returned.
 </summary>
 <param name="table"></param>
 <param name="keys">The subset of columns used as matching keys.</param>
 <param name="cols">The set of column/name value pairs, including keys, to write.</param>
</member>
<member name="">

</member>
<member name="M:Marvel.Data.SQL.deleteInsertSQL(System.String,Microsoft.FSharp.Collections.FSharpList{System.String},System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Object}})">
 <summary>
 Generates SQL DELETE and INSERT statements to update a row.
 </summary>
 <param name="table"></param>
 <param name="keys">A subset of the columns which are foreign keys, used to identify the child row to update.</param>
 <param name="cols">The set of column/name value pairs, including keys, to write.</param>
 <returns>A SQL string or String.Empty if no columns are provided.</returns>
</member>
<member name="">

</member>
<member name="M:Marvel.Data.SQL.deleteSQL(System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Object}})">
 <summary>
 Generates a SQL DELETE statement which deletes a row matched by the provided keys.
 </summary>
 <param name="table"></param>
 <param name="keys">The set of key/value pairs used to identify the record to delete.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Data.SQL.insertSQL(System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Object}})">
 <summary>
 Generates a SQL INSERT statement.
 </summary>
 <param name="table"></param>
 <param name="values">The set of column value pairs to insert.</param>
</member>
<member name="">

</member>
<member name="M:Marvel.Data.SQL.toSqlStringValues(System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Object}})">
<summary>
 Converts column values to a formatted SQL string and returns the resulting
 column/value pairs as separate sequences.
</summary>
</member>
<member name="M:Marvel.Data.SQL.toCol``1(System.String,``0)">
<summary>
 Convenience function to create column-value pair.
</summary>
</member>
<member name="M:Marvel.Data.SQL.execTx(System.String,System.String)">
<summary>
 Executes a SQL command within a transaction at the SQL Server default ReadCommitted isolation level.
</summary>
</member>
<member name="M:Marvel.Data.SQL.execTxIso(System.String,System.Data.IsolationLevel,System.String)">
<summary>
 Executes a SQL command within a transaction at a specific isolation level.
</summary>
</member>
<member name="M:Marvel.Data.SQL.bulkExec(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Executes a sequence of SQL commands.
</summary>
</member>
<member name="M:Marvel.Data.SQL.exec(System.String,System.String)">
<summary>
 Executes a SQL command. If the command is empty returns -1.
</summary>
</member>
<member name="M:Marvel.Data.SQL.execCmdTx(System.String,System.Data.SqlClient.SqlCommand)">
<summary>
 Executes the specified command on the specified connection within a transaction.
 If the command object is null or contains no command, -1 is returned.
 After execution, the command object is disposed.
</summary>
</member>
<member name="M:Marvel.Data.SQL.execCmd(System.String,System.Data.SqlClient.SqlCommand)">
<summary>
 Executes the specified command on the specified connection.
 If the command object is null or contains no command, -1 is returned.
 After execution, the command object is disposed.
</summary>
</member>
<member name="M:Marvel.Data.SQL.bulkCopyFromMappings``1(System.String,System.String,System.Int32,System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object}}})">
<summary>
 Performs a SQL bulk copy into a table from a sequence based on a set of data mappings.
</summary>
</member>
<member name="M:Marvel.Data.SQL.bulkCopyStream(System.String,System.String,System.Int32,System.Data.IDataReader)">
<summary>
 Performs a SQL bulk copy into a table from the specified IDataReader. 
 The data is streamed from the IDataReader rather than being loaded all into memory.
</summary>
</member>
<member name="M:Marvel.Data.SQL.bulkCopyTimeout(System.String,System.String,System.Int32,System.Int32,System.Data.IDataReader)">
<summary>
 Performs a SQL bulk copy into a table from the specified IDataReader.
</summary>
</member>
<member name="M:Marvel.Data.SQL.bulkCopy(System.String,System.String,System.Int32,System.Data.IDataReader)">
<summary>
 Performs a SQL bulk copy into a table from the specified IDataReader.
</summary>
</member>
<member name="M:Marvel.Data.SQL.singleAsync``1(System.String,System.String,Microsoft.FSharp.Core.FSharpFunc{System.Data.IDataRecord,``0})">
<summary>
 Returns the first row of query results.
</summary>
</member>
<member name="M:Marvel.Data.SQL.single``1(System.String,System.String,Microsoft.FSharp.Core.FSharpFunc{System.Data.IDataRecord,``0})">
<summary>
 Returns the first row of query results.
</summary>
</member>
<member name="M:Marvel.Data.SQL.stream``1(System.String,System.String,Microsoft.FSharp.Core.FSharpFunc{System.Data.IDataRecord,``0})">
<summary>
 Returns rows of a query as IDataRecord instances and applies a function to each.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Data.SQL.Conn">

</member>
<member name="M:Marvel.Data.SQL.Infixes.op_HatEquals``1(System.String,``0)">
<summary>
 Infix operator for creating a column value pair.
</summary>
</member>
<member name="T:Marvel.Data.SQL.Infixes">

</member>
<member name="M:Marvel.Data.SQL.Retry.Default``1">
<summary>
 Applies the default retry strategy consisting of
 a transient exception filter, an expontential, bounded and randomized retry
 and 3 total attempts.
</summary>
</member>
<member name="M:Marvel.Data.SQL.Retry.TransientExceptionFilter(System.Exception)">
<summary>
 An exception filter which returns true for transient exceptions which should be retried.
</summary>
</member>
<member name="M:Marvel.Data.SQL.Retry.isTransientErrorCode(System.Int32)">
<summary>
 Determines whether the error number (SqlError.Number) indicates a transient failure
 which can be compensated through retry.
 (select * from master.dbo.sysmessages)
</summary>
</member>
<member name="T:Marvel.Data.SQL.Retry">
<summary>
 Retry logic.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.Data.SQL.Param">

</member>
<member name="T:Marvel.Data.SQL">
<summary>
 SQL functions.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Data.SqlClientEx">

</member>
<member name="M:Marvel.Data.DataReader.ofKvps``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.String,System.Object}[]},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Creates an IDataReader for an 'a seq based on key-value pair mappings for individual 'a values.
 </summary>
 <param name="m">A function which when given an individual 'a deterministically maps to a set of column name and value pairs.</param>
 <remarks>
 - It is expected that the mapping function produces column name and value pairs in the same order.
 - When this function is called, the first item is read in order to initialize the schema.
 </remarks>
</member>
<member name="M:Marvel.Data.DataReader.ofRows``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Creates an IDataReader for an 'a seq based on key-value pair mappings for individual 'a values.
 </summary>
 <param name="rows">A function which when given an individual 'a deterministically maps to a set of rows (set of column name and value pairs).</param>
 <remarks>
 - It is expected that the mapping function produces column name and value pairs in the same order.
 - When this function is called, the first item is read in order to initialize the schema.
 </remarks>
</member>
<member name="M:Marvel.Data.DataReader.ofMappings``1(System.Collections.Generic.IEnumerable{System.Tuple{System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object}}})">
<summary>
 Creates an IDataReader given a set of mappings.
</summary>
</member>
<member name="M:Marvel.Data.DataReader.trySingle``1(Microsoft.FSharp.Core.FSharpFunc{System.Data.IDataRecord,``0},System.Data.IDataReader)">
<summary>
 Tries to read a single record from the reader.
</summary>
</member>
<member name="M:Marvel.Data.DataReader.map``1(Microsoft.FSharp.Core.FSharpFunc{System.Data.IDataRecord,``0},System.Data.IDataReader)">
<summary>
 Maps a function over the recrods in a IDataReader.
</summary>
</member>
<member name="T:Marvel.Data.DataReader">
<summary>
 IDataReader functions.
</summary>
</member>
<member name="M:Marvel.Data.SqlValue.toSqlString(System.Object)">
<summary>
 Converts an object to a string representation to be used within a SQL query string.
 Note, there is support for a limited number of primitive types.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Data.SqlValue.toSqlValue(System.Object)">
 <summary>
 Converts an object to a representation suitable for a SQL command.
 Specifically, it converts null to DBNull.Value, option&lt;'a&gt; to the corresponding reference or Nullable representation.
 Other values as passed on.
 </summary>
 <param name="a"></param>
</member>
<member name="T:Marvel.Data.SqlValue">
<summary>
 Operations for mapping between objects and SQL values.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Data.DataRecordEx">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Data.DataRecord">
<summary>
 Operations for reading from IDataRecord
</summary>
</member>
<member name="M:Marvel.Data.DataMapping.contramap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.String,Microsoft.FSharp.Core.FSharpFunc{``1,System.Object})">
<summary>
 Given function (&apos;b -&gt; &apos;a) and DataMapping&lt;&apos;a&gt; produces DataMapping&lt;&apos;b&gt;
</summary>
</member>
<member name="M:Marvel.Data.DataMapping.col``1(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.Object})">
<summary>
 Gets the column name for the mapping.
</summary>
</member>
<member name="M:Marvel.Data.DataMapping.op_EqualsEqualsGreater``2">
<summary>
 Creates a mapping between an object property and a data field.
</summary>
</member>
<member name="M:Marvel.Data.DataMapping.mapProp``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a mapping between an object property and a data field.
</summary>
</member>
<member name="T:Marvel.Data.DataMapping">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Dict">

</member>
<member name="">

</member>
<member name="T:Marvel.Environment.Environment">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Faults">

</member>
<member name="M:Marvel.Filter.doAfterAsync``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Performs an action after the service completes with both the input and output of the service.
 The result of the action is discarded.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Filter.countAndTimeAfterBatch``2(Marvel.TimedCounter)">
<summary>
 Counts invocations of a service using a timer which aggregates counts and prints results to the console every second.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Filter.countAndTimeAfter``2(Marvel.TimedCounter)">
<summary>
 Counts invocations of a service using a timer which aggregates counts and prints results to the console every second.
</summary>
</member>
<member name="M:Marvel.Filter.after``2(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Executes a callback after invoking the service.
</summary>
</member>
<member name="M:Marvel.Filter.before``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Executes a callback before invoking the service.
</summary>
</member>
<member name="M:Marvel.Filter.catchLogTo``2(NLog.Logger)">
<summary>
 Wraps the service in a try/with block and logs errors.
</summary>
</member>
<member name="M:Marvel.Filter.logErrorTo``3(NLog.Logger)">
<summary>
 Logs erroneous results.
</summary>
</member>
<member name="M:Marvel.Filter.catchNotify``2(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Exception},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0)">
<summary>
 Wraps the service in a try/with block and notifies a callback on exceptions.
</summary>
</member>
<member name="M:Marvel.Filter.notifyError``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Exception},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},``0)">
<summary>
 Notifies a callback when an erroneous result is returned by a service.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Filter.countAndLogTo``2(System.Int32,NLog.Logger)">
<summary>
 Counts invocations of a service and logs them at a specified interval.
</summary>
</member>
<member name="M:Marvel.Filter.count``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit})">
<summary>
 Counts invocations of a service and notifies a callback at a specified interval.
</summary>
</member>
<member name="M:Marvel.Filter.whereAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},Microsoft.FSharp.Control.FSharpAsync{``1},``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 A filter which filters inputs to a service based on a specified predicate.
 Only inputs satisfying the predicate will be handed to the service. Otherwise, @defaultValue will be returned.
 Note that @defaulValue can cause side-effects.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Filter.timing``2(NLog.Logger,``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Log elapsed milliseconds for each execution of service
</summary>
</member>
<member name="M:Marvel.Filter.sequenceBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.String},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Ensures that execution of inputs with the same keys are processed sequentially.
</summary>
</member>
<member name="M:Marvel.Filter.sequence``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.String})">
<summary>
 A filter which ensures that inputs mapping to the same key will be processed in sequential order.            
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Filter.beforeAfterExSync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Exception},``1},``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Injects functions before, after and upon error of a service.
</summary>
</member>
<member name="M:Marvel.Filter.beforeAfterSync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},Microsoft.FSharp.Core.Unit},``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Invokes a synchronous function before and after calling a service.
</summary>
</member>
<member name="M:Marvel.Filter.apply``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``3}}},``2)">
<summary>
 Applies a filter to a service returning a filtered service.
</summary>
</member>
<member name="M:Marvel.Filter.monoid``2">
<summary>
 The monoid instance for a filter.
</summary>
</member>
<member name="M:Marvel.Filter.identity``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 The identity filter which passes the input directly to the service and propagates the output.
</summary>
</member>
<member name="M:Marvel.Filter.andThen``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Control.FSharpAsync{``3}}},Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``3}},Microsoft.FSharp.Control.FSharpAsync{``3}}},``4)">
<summary>
 Composes two filters into one which calls the first one, then the second one.
</summary>
</member>
<member name="T:Marvel.Filter">

</member>
<member name="T:Marvel.Http.HttpCodec`1">
<summary>
 A codec for HTTP request and response messages.
</summary>
</member>
<member name="M:Marvel.Http.HttpHost.host(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Net.Http.HttpRequestMessage,Microsoft.FSharp.Control.FSharpAsync{System.Net.Http.HttpResponseMessage}})">
<summary>
 Hosts the provided HTTP service at the specified Uri prefix using HttpListener.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Http.HttpHost.Config">

</member>
<member name="T:Marvel.Http.HttpHost">
<summary>
 Operations for hosting HTTP services.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.Http.HttpCodec">
<summary>
 Operations on HTTP codecs.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Http.HttpRes.bodyToStream(System.Net.Http.HttpResponseMessage)">
<summary>
 Reads the body of an HTTP response as a byte array.
</summary>
</member>
<member name="M:Marvel.Http.HttpRes.bodyToBytes(System.Net.Http.HttpResponseMessage)">
<summary>
 Reads the body of an HTTP response as a byte array.
</summary>
</member>
<member name="M:Marvel.Http.HttpRes.bodyToString(System.Net.Http.HttpResponseMessage)">
<summary>
 Reads the body of an HTTP response as a string.
</summary>
</member>
<member name="T:Marvel.Http.HttpRes">
<summary>
 Operations on System.Net.HttpResponseMessage
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Http.HttpReq.getPath(System.String)">
<summary>
 Creates an HTTP GET request to the specified path.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.delete">
<summary>
 Creates an HTTP DELETE request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.post">
<summary>
 Creates an HTTP POST request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.put">
<summary>
 Creates an HTTP PUT request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.get">
<summary>
 Creates an HTTP GET request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withUserAgent(System.String,System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns an User-Agent header to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withHeaders(System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.String}},System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns the specified headers to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withContentType(System.String,System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns a media type to the body of an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withBodyStream(System.IO.Stream,System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns a stream body to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withBodyByteSeg(System.ArraySegment{System.Byte},System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns a byte array body to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.ofBodyBytes(System.Byte[])">
<summary>
 Assigns a byte array body to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withBodyBytes(System.Byte[],System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns a byte array body to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withBodyString(System.String,System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns a string body to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withMethod(System.Net.Http.HttpMethod,System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns a method to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withPath(System.String,System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns a path to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.withUri(System.Uri,System.Net.Http.HttpRequestMessage)">
<summary>
 Assigns a path to an HTTP request.
</summary>
</member>
<member name="M:Marvel.Http.HttpReq.create">
<summary>
 Creates an HTTP GET request.
</summary>
</member>
<member name="T:Marvel.Http.HttpReq">
<summary>
 Operations on System.Net.HttpRequestMessage
</summary>
</member>
<member name="M:Marvel.Http.HttpClient.withTimeout``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Assigns the number of milliseconds to wait before the request times out.
</summary>
</member>
<member name="M:Marvel.Http.HttpClient.baseAddress(System.String)">
<summary>
 Creates an HTTP client for the specified host url.
</summary>
</member>
<member name="M:Marvel.Http.HttpClient.baseAddressUri(System.Uri)">
<summary>
 Creates an HTTP client for the specified host url.
</summary>
</member>
<member name="T:Marvel.Http.HttpClient">
<summary>
 Operations on System.Net.HttpClient.
</summary>
</member>
<member name="M:Marvel.IO.ofByteSeq(System.Collections.Generic.IEnumerable{System.Byte})">
<summary>
 Converts a sequence of bytes to a read-only Stream.
</summary>
</member>
<member name="T:Marvel.IO">

</member>
<member name="">

</member>
<member name="T:Marvel.IOExtensions">

</member>
<member name="M:Marvel.IVar.get``1(Marvel.IVar{``0})">
<summary>
 Creates an async computation which returns the value contained in an IVar.  
</summary>
</member>
<member name="M:Marvel.IVar.cancel``1(Marvel.IVar{``0})">
<summary>
 Writes a cancellation to an IVar to be propagated to readers.
</summary>
</member>
<member name="M:Marvel.IVar.error``1(System.Exception,Marvel.IVar{``0})">
<summary>
 Writes an error to an IVar to be propagated to readers.
</summary>
</member>
<member name="M:Marvel.IVar.put``1(``0,Marvel.IVar{``0})">
<summary>
 Writes a value to an IVar.
 A value can only be written once, after which the behavior is undefined and may throw.
</summary>
</member>
<member name="M:Marvel.IVar.createFull``1(``0)">
<summary>
 Creates a IVar structure and initializes it with a value.
</summary>
</member>
<member name="M:Marvel.IVar.create``1">
<summary>
 Creates an empty IVar structure.
</summary>
</member>
<member name="T:Marvel.IVar">
<summary>
 Operations on write-once variables.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.IdHelper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.InterlockedExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Lens.asList``2(Marvel.Lens{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Creates a list lens from an option lens.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Lens.appendList``2(Marvel.Lens{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Creates a lens which returns the first item, if any, of a list and prepends an item, if any, to a list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Lens.compose``3(Marvel.Lens{``0,``1},Marvel.Lens{``1,``2})">
<summary>
 Composes two lenses into one.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Lens.mapSet``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Marvel.Lens{``2,``1})">
<summary>
 Contravariant map.
</summary>
</member>
<member name="M:Marvel.Lens.iso``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Marvel.Lens{``2,``0})">
<summary>
 Creates an isomorphism for a lens given f and g (Profunctor).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Lens">

</member>
<member name="M:Marvel.LensLaws.law3``2(Marvel.Lens{``0,``1},``0,``1,``1)">
<summary>
 Settings once is equal to settings multiple times as long as the last set values are equal.
</summary>
</member>
<member name="M:Marvel.LensLaws.law2``2(Marvel.Lens{``0,``1},``0)">
<summary>
 Settings after gettings leaves the root value unchanged.
</summary>
</member>
<member name="M:Marvel.LensLaws.law1``2(Marvel.Lens{``0,``1},``0,``1)">
<summary>
 Getting after setting gives back the same value.
</summary>
</member>
<member name="T:Marvel.LensLaws">

</member>
<member name="M:Marvel.LensOps.op_AdditionAssignment``3(Marvel.Lens{``0,``1},``2)">
<summary>
 Creates a state transition which increments a numeric value lens.
</summary>
</member>
<member name="M:Marvel.LensOps.op_ColonEquals``2(Marvel.Lens{``0,``1},``1)">
<summary>
 Creates a state transition which assigns a value to a lens.
</summary>
</member>
<member name="M:Marvel.LensOps.op_GreaterEqualsGreater``3(Marvel.Lens{``0,``1},Marvel.Lens{``1,``2})">
<summary>
 Composes lenses.
</summary>
</member>
<member name="T:Marvel.LensOps">

</member>
<member name="M:Marvel.List.foldT``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``1}}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Like List.fold but supports early termination by having f return None.
</summary>
</member>
<member name="M:Marvel.List.partitionChoices``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpChoice{``0,``1}})">
<summary>
 Partitions a list of choices between &apos;a and &apos;b into separate lists of &apos;a and &apos;b.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.List.contains``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Determines whether a kust contains a value.
</summary>
</member>
<member name="M:Marvel.List.mapAccum``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Threads state through a collection using fold to generate a new collection.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.List.snoc``1(Microsoft.FSharp.Collections.FSharpList{``0},``0)">
<summary>
 Append O(N).
</summary>
</member>
<member name="M:Marvel.List.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Prepend O(1).
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.ListTuple">

</member>
<member name="M:Marvel.LogModule.create(System.String)">
<summary>
 Creates a logger
</summary>
</member>
<member name="M:Marvel.LogModule.configFromXml(System.String)">
<summary>
 Configures NLog based on an NLog.config file in the specified directory.
</summary>
</member>
<member name="M:Marvel.LogModule.To.file(System.String,System.String,NLog.LogLevel)">
<summary>
 Adds a file target to the configuration and adds a rule to direct the specified logger to the target.
</summary>
</member>
<member name="M:Marvel.LogModule.To.trace(System.String,NLog.LogLevel)">
<summary>
 Adds a Systems.Diagnostics.Trace target to the configuration and a rule.
</summary>
</member>
<member name="M:Marvel.LogModule.To.coloredConsole(System.String,NLog.LogLevel)">
<summary>
 Adds a colored console target to the configuration and a rule.
</summary>
</member>
<member name="M:Marvel.LogModule.To.console(System.String,NLog.LogLevel)">
<summary>
 Adds a console target to the configuration and a rule.
</summary>
</member>
<member name="M:Marvel.LogModule.To.target``1(System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.String,NLog.LogLevel)">
<summary>
 Adds a logging target and a logging rule associated with the target.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.LogModule.To">
<summary>
 Utilities for adding listeners to loggers.
</summary>
</member>
<member name="T:Marvel.LogModule">

</member>
<member name="M:Marvel.Map.missingKeys``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Searches the map for the specified keys and if any are missing returns Choice2Of2 with 
 all of the missing keys, otherwise returns the provided map.
</summary>
</member>
<member name="M:Marvel.Map.merge``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Merges two maps favoring values from the second.
</summary>
</member>
<member name="M:Marvel.Map.mergeWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2}}}},Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Merges two maps usinf the specified function which receives the key, the value from the
 left map and the value from the right map and produces a value for the resulting map.
</summary>
</member>
<member name="M:Marvel.Map.onlyKeys``2(Microsoft.FSharp.Collections.FSharpSet{``0},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Filters a map such that the resulting 
</summary>
</member>
<member name="M:Marvel.Map.keys``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Gets the set of keys.
</summary>
</member>
<member name="M:Marvel.Map.replace``2(``0,``1,Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Replaces the value associated with a key. If the key isn&apos;t there, adds it.
</summary>
</member>
<member name="T:Marvel.Map">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.MessageIdentity">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Monoid">

</member>
<member name="M:Marvel.MonoidLaws.law3``1(Marvel.Monoid{``0},``0,``0,``0)">
<summary>
 Associative.
</summary>
</member>
<member name="M:Marvel.MonoidLaws.law2``1(Marvel.Monoid{``0},``0)">
<summary>
 Right identity.
</summary>
</member>
<member name="M:Marvel.MonoidLaws.law1``1(Marvel.Monoid{``0},``0)">
<summary>
 Left identity.
</summary>
</member>
<member name="T:Marvel.MonoidLaws">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.NLoggerEx">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Node">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.PLens">
<summary>
 Partial lens.
</summary>
</member>
<member name="M:Marvel.PLensOps.op_AdditionAssignment``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},``1)">
<summary>
 Creates a state transition which increments a numeric value lens.
</summary>
</member>
<member name="M:Marvel.PLensOps.op_ColonEquals``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},``1)">
<summary>
 Creates a state transition which assigns a value to a lens.
</summary>
</member>
<member name="M:Marvel.PLensOps.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``2,Microsoft.FSharp.Core.FSharpFunc{``2,``1}}}})">
<summary>
 Composes partial lenses.
</summary>
</member>
<member name="T:Marvel.PLensOps">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.PSeqModule">
<summary>
 Parallel operations on sequences.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Prelude.Failure``2(``0)">
<summary>
 Indicates failure as Choice2Of2
</summary>
</member>
<member name="M:Marvel.Prelude.Success``2(``0)">
<summary>
 Indicates success as Choice1Of2
</summary>
</member>
<member name="M:Marvel.Prelude.|Success|Failure|``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Active pattern for matching a Choice&lt;&apos;a, &apos;b&gt; with Choice1Of2 = Success and Choice2Of2 = Failure
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Marvel.Prelude.maybe">
<summary>
 The maybe monad workflow builder.
</summary>
</member>
<member name="M:Marvel.Prelude.mapTriple``6(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpFunc{``4,``5},``0,``2,``4)">
<summary>
 Maps over the first item of a tuple.
</summary>
</member>
<member name="M:Marvel.Prelude.mapThd3``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``3,``0)">
<summary>
 Maps over the first item of a tuple.
</summary>
</member>
<member name="M:Marvel.Prelude.mapSnd3``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0,``3)">
<summary>
 Maps over the first item of a tuple.
</summary>
</member>
<member name="M:Marvel.Prelude.mapFst3``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2,``3)">
<summary>
 Maps over the first item of a tuple.
</summary>
</member>
<member name="M:Marvel.Prelude.mapPair``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},``0,``2)">
<summary>
 Maps over individual items of a pair.
</summary>
</member>
<member name="M:Marvel.Prelude.mapSnd``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2,``0)">
<summary>
 Maps over the second item of a tuple.
</summary>
</member>
<member name="M:Marvel.Prelude.mapFst``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,``2)">
<summary>
 Maps over the first item of a tuple.
</summary>
</member>
<member name="M:Marvel.Prelude.diag``1(``0)">
<summary>
 Duplicate a value into a pair (diagonal morphism).
</summary>
</member>
<member name="M:Marvel.Prelude.isNotNull``1(``0)">
<summary>
 Determines whether the argument is not a null reference.
</summary>
</member>
<member name="M:Marvel.Prelude.isNull``1(``0)">
<summary>
 Determines whether the argument is a null reference.
</summary>
</member>
<member name="M:Marvel.Prelude.op_Concatenate``2">
<summary>
 Sequencing operator like Haskell&apos;s ($). Has better precedence than (&lt;|) due to the
 first character used in the symbol.
</summary>
</member>
<member name="M:Marvel.Prelude.op_MultiplyMultiplyMultiply``4">
<summary>
 Split the input between the two argument functions and combine their output.
</summary>
</member>
<member name="M:Marvel.Prelude.fsplit``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},``0,``2)">
<summary>
 Split the input between the two argument functions and combine their output.
 See (***) in http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Arrow.html
</summary>
</member>
<member name="M:Marvel.Prelude.tap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Return the first argument after applying f to it. Useful for debugging chains of (|&gt;)
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Prelude.op_EqualsGreater``2(``0,``1)">
<summary>
 Tuple convenience operator.
</summary>
</member>
<member name="M:Marvel.Prelude.op_BangBang``2(``0)">
<summary>
 Explicit operator.
</summary>
</member>
<member name="M:Marvel.Prelude.op_BangGreater``2(``0)">
<summary>
 Implicit operator.
</summary>
</member>
<member name="M:Marvel.Prelude.op_BarQmark``1(``0,``0)">
<summary>
 Null-coalescing operator.
</summary>
</member>
<member name="M:Marvel.Prelude.failwithumf``1">
<summary>
 Fail with an unexpected match failure.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Prelude.konst2``3(``0,``1,``2)">
<summary>
 Given a value, creates a function with two ignored arguments which returns the value.
</summary>
</member>
<member name="M:Marvel.Prelude.konst``2(``0,``1)">
<summary>
 Given a value, creates a function with one ignored argument which returns the value.
</summary>
</member>
<member name="M:Marvel.Prelude.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
<summary>
 Transforms a curried function to a non-curried function.
</summary>
</member>
<member name="M:Marvel.Prelude.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``0,``1)">
<summary>
 Transforms an uncurried function to a curried function.
</summary>
</member>
<member name="M:Marvel.Prelude.flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``1,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:Marvel.Prelude.fix``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0)">
<summary>
 Fixed point combinator.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Prelude.Dict">
<summary>
 Basic operations on dictionaries.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Prelude.Option.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Applies a function to values contained in both options when both are Some.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.liftSnd``2(Microsoft.FSharp.Core.FSharpOption{``0},``1)">
<summary>
 Lifts the second element of a pair into an option based on the value of the first element option.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.liftFst``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Lifts the first element of a pair into an option based on the value of the second element option.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.strength``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Converts a pair of a value and an optional value into an optional value containing a pair.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.tryWith``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Return Some (f ()) if f doesn&apos;t raise. None otherwise
</summary>
</member>
<member name="M:Marvel.Prelude.Option.foldOrLazy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Folds an option by applying f to Some otherwise returning the default value.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.foldOr``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``1,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Folds an option by applying f to Some otherwise returning the default value.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.merge``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Merges two options into one by returning the first if it is Some otherwise returning the second.
 This operation is not commutative but is associative.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Prelude.Option.getValueOrDefault``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the Some value or Unchecked.defaultof&lt;&apos;a&gt;.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.isNullLazy``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Given a default value and an option, returns the option value if there else the default value.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.getValueOr``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Given a default value and an option, returns the option value if there else the default value.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.isNull``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Given a default value and an option, returns the option value if there else the default value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Prelude.Option.toNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts an option to a corresponding nullable.
</summary>
</member>
<member name="M:Marvel.Prelude.Option.emptyNullable``1">
<summary>
 An empty nullable value of a type designated by use.
</summary>
</member>
<member name="T:Marvel.Prelude.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Prelude.ToDelegate">
<summary>
 Helpers for converting functions to System.Func&lt;T,..&gt; delegates
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Prelude.Tuple">

</member>
<member name="T:Marvel.Prelude">

</member>
<member name="M:Marvel.Process.RequireCurrentProcessAdmin">
<summary>
 Require that the current process is being run with administration privileges.
</summary>
</member>
<member name="M:Marvel.Process.IsCurrentProcessAdmin">
<summary>
 Query that the current process is being run with administration privileges.
</summary>
</member>
<member name="M:Marvel.Process.StartScriptAsAdmin(System.String,System.String)">
<summary>
 Run an Fsx script file in a new Fsi process with administration privileges.
</summary>
</member>
<member name="M:Marvel.Process.StartAsAdmin(System.String,System.String)">
<summary>
 Start a process with administration priveleges
</summary>
</member>
<member name="T:Marvel.Process">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Rand">
<summary>
 RNG combinators.
</summary>
</member>
<member name="P:Marvel.RandBuilder.rand">
<summary>
 RNG workflow builder.
</summary>
</member>
<member name="T:Marvel.RandBuilder">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Reader.reader``1(``0)">
<summary>
 just for compatibility in case anyone still uses it.
</summary>
</member>
<member name="T:Marvel.Reader">

</member>
<member name="P:Marvel.ReaderBuilder.reader">
<summary>
 Reader monad workflow builder.
</summary>
</member>
<member name="T:Marvel.ReaderBuilder">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.ResizeArray">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Rx.Observable.subscribeAsync``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}})">
<summary>
 Subscribes to an observable invoking the specified asynchronous action. Observed events are placed into an internal queue buffer
 which is processed by a specified number of workers.
</summary>
</member>
<member name="M:Marvel.Rx.Observable.bufferWithTimeOrCount``1(System.TimeSpan,System.Int32,System.IObservable{``0})">
<summary>
 Buffers the observable sequence by a buffer size or a timeout.
 When the current batch is full, it blocks the source observable.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Rx.Observable.interval(System.TimeSpan)">
<summary>
 Creates an observable sequence which emits events at a fixed interval.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Rx.Observable">

</member>
<member name="M:Marvel.Seq.partitionChoices``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpChoice{``0,``1}})">
<summary>
 Partitions a sequence of choices between &apos;a and &apos;b into separate sequences of &apos;a and &apos;b.
</summary>
</member>
<member name="M:Marvel.Seq.groupByOfOrdered``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Performs a group by assuming that the sequence is ordered by the specified key.
 This reduces memory use because an internal hash table isn&apos;t required to maintain the grouping.
</summary>
</member>
<member name="M:Marvel.Seq.toLookup``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a lookup map from a sequnce based on a key.
</summary>
</member>
<member name="M:Marvel.Seq.toLookupMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a lookup map from a sequnce based on a key and value selection function.
</summary>
</member>
<member name="M:Marvel.Seq.toKeyMap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a map from a sequnce based on a key.
</summary>
</member>
<member name="M:Marvel.Seq.toKeyValueMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a map from a sequnce based on a key and value selection function.        
</summary>
</member>
<member name="M:Marvel.Seq.contains``1(``0,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Determines whether a sequence contains a value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Seq.mapAccum``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Threads state through a collection using fold to generate a new collection.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Seq.maxOr``1(``0,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the maximum element in the sequence or the default value if empty.
</summary>
</member>
<member name="M:Marvel.Seq.minOr``1(``0,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the minimum element in the sequence or the default value if empty.
</summary>
</member>
<member name="M:Marvel.Seq.batchSizes(System.Int32,System.Int32)">
<summary>
 Generates a sequence of batch sizes which add up to the specified count.
</summary>
</member>
<member name="M:Marvel.Seq.batch``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets a collection of batches of subsequent elements of a collection.
</summary>
</member>
<member name="M:Marvel.Seq.tryLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets the last element in the collection or None. TODO: optimize
</summary>
</member>
<member name="M:Marvel.Seq.tryFirst``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets the first element in the collection or None.
</summary>
</member>
<member name="M:Marvel.Seq.tryNth``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets the n-th element in the collection or None.
</summary>
</member>
<member name="M:Marvel.Seq.anyWhere``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets a value indicating whether the collection has any elements satisfying the predicate.
</summary>
</member>
<member name="M:Marvel.Seq.any``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Gets a value indicating whether the collection has any elements.
</summary>
</member>
<member name="M:Marvel.Seq.join``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Monadic join for seq.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Seq.append1``1(System.Collections.Generic.IEnumerable{``0},``0)">
<summary>
 Appends a single item at the end of the sequence.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Seq.cons``1(``0,System.Collections.Generic.IEnumerable{``0})">
<summary>
 List.Cons for sequences.
</summary>
</member>
<member name="M:Marvel.Seq.Laws.GroupByOfOrdered.law2``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Each key appears exactly once in grouping.
</summary>
</member>
<member name="M:Marvel.Seq.Laws.GroupByOfOrdered.law1``2(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Groups contain all values.
</summary>
</member>
<member name="T:Marvel.Seq.Laws.GroupByOfOrdered">

</member>
<member name="M:Marvel.Seq.Laws.Batch.law1(Microsoft.FSharp.Collections.FSharpList{System.Int32},System.Int32)">
<summary>
 Batching is reversed by concatenation.
</summary>
</member>
<member name="T:Marvel.Seq.Laws.Batch">

</member>
<member name="T:Marvel.Seq.Laws">

</member>
<member name="T:Marvel.Seq">

</member>
<member name="">

</member>
<member name="M:Marvel.Service.loggingFilter``1(NLog.Logger)">
<summary>
 Writes to a log before an input is handled and during an exception.
</summary>
</member>
<member name="M:Marvel.Service.pipe``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{``3}}},``0)">
<summary>
 Creates a consumer of a raw input consiting of a decoder, a logic handler and an encoder.
</summary>
</member>
<member name="M:Marvel.Service.consumeBatch``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``1},Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Core.FSharpFunc{``0[],Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},``0[])">
<summary>
 Creates a consumer of a raw input consiting of a decoder, a logic handler and an effectful interpreter.
 This encapsulates the general pattern of decoding external input, invoking pure business logic and interpreting the output in an infrastructure specific way.
</summary>
</member>
<member name="M:Marvel.Service.consume``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}},``0)">
<summary>
 Creates a consumer of a raw input consiting of a decoder, a logic handler and an effectful interpreter.
 This encapsulates the general pattern of decoding external input, invoking pure business logic and interpreting the output in an infrastructure specific way.
</summary>
</member>
<member name="M:Marvel.Service.filterWith``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},Microsoft.FSharp.Control.FSharpAsync{``3}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}})">
<summary>
 Applies a filter to a service returning a filtered service.
</summary>
</member>
<member name="T:Marvel.Service">

</member>
<member name="M:Marvel.Setter.optionGetDefault``2(Marvel.Setter{``0,``1})">
<summary>
 Convertes a setter to a setter which optionally accepts a value and uses the default value for None.
</summary>
</member>
<member name="M:Marvel.Setter.optionGetOr``2(``0,Marvel.Setter{``1,``0})">
<summary>
 Convertes a setter to a setter which optionally accepts a value and uses the specified default value for None.
</summary>
</member>
<member name="M:Marvel.Setter.optionGet``2(Marvel.Setter{``0,``1})">
<summary>
 Convertes a setter to a setter which optionally accepts a value but throws an exception if the value isn&apos;t there.
</summary>
</member>
<member name="M:Marvel.Setter.option``2(Marvel.Setter{``0,``1})">
<summary>
 Convertes a setter to a setter which optionally accepts a value and if does nothing if None.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Setter.tryFirstList``2(Marvel.Setter{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Converts an option setter to a list setter based on the first element.
</summary>
</member>
<member name="M:Marvel.Setter.mapTo``3(Marvel.Setter{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1})">
<summary>
 Contravariant mapping between setters.
</summary>
</member>
<member name="M:Marvel.Setter.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Marvel.Setter{``2,``1})">
<summary>
 Contravariant mapping between setters.
</summary>
</member>
<member name="M:Marvel.Setter.ofLens``2(Marvel.Lens{``0,``1})">
<summary>
 Extracts a setter from a lens.
</summary>
</member>
<member name="M:Marvel.Setter.set``2(Marvel.Setter{``0,``1},``0,``1)">
<summary>
 Sets a value.
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.Setter">
<summary>
 Utilities for a setter.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.ShardKey.crc32(System.String)">
<summary>
 Returns the CRC-32 value of &apos;name&apos; as specified by RFC1952
</summary>
</member>
<member name="">

</member>
<member name="T:Marvel.ShardKey.Internal">

</member>
<member name="T:Marvel.ShardKey">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.State.traverseList``3(Microsoft.FSharp.Core.FSharpFunc{``0,Marvel.State{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates a state transition which evaluates the list of state transitions and returns the list of results.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.State.traverseArray``3(Microsoft.FSharp.Core.FSharpFunc{``0,Marvel.State{``1,``2}},``0[])">
<summary>
 Creates a state transition which evaluates the array of state transitions and returns the array of results.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.State">
<summary>
 The state monad.
</summary>
</member>
<member name="P:Marvel.StateBuilder.state">
<summary>
 State monad workflow builder.
</summary>
</member>
<member name="T:Marvel.StateBuilder">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.StateLaws">

</member>
<member name="M:Marvel.String.trimToLength(System.Int32,System.String)">
<summary>
 Trims a string to ensure that it is equal to or less than the specified length.
 Null strings are returned as is.
</summary>
</member>
<member name="M:Marvel.String.isWhitespace(System.String)">
<summary>
 Query that a string is nothing more than whitespace.
</summary>
</member>
<member name="M:Marvel.String.rev(System.String)">
<summary>
 Reverse a string.
</summary>
</member>
<member name="M:Marvel.String.splitAt(System.Int32,System.String)">
<summary>
 Splits the string at the specified index returning the part before the index and the part after the index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.String">

</member>
<member name="M:Marvel.StringPatterns.|InvariantEqual|_|(System.String,System.String)">
<summary>
 Active pattern for matching strings with case insensitive comparison.
</summary>
</member>
<member name="T:Marvel.StringPatterns">

</member>
<member name="">

</member>
<member name="M:Marvel.Strings.trimStartI(System.String,System.String)">
<summary>
 Strips a substring from the beginning of a string if it starts with the substring, ignoring case.
</summary>
</member>
<member name="M:Marvel.Strings.|RegexGroup|_|(System.String,System.String)">
<summary>
 Obtains a single pattern group, if one exists
</summary>
</member>
<member name="M:Marvel.Strings.|RegexMatch|_|(System.String,System.String)">
<summary>
 Obtains a single pattern match for a string, if one exists.
</summary>
</member>
<member name="M:Marvel.Strings.|RegexMatches|_|(System.String,System.String)">
<summary>
 Obtains all pattern matches for a string, if any.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Strings.splitSRE(System.String[],System.String)">
<summary>
 Splits a string removing empty entries.
</summary>
</member>
<member name="M:Marvel.Strings.splitS(System.String[],System.String)">
<summary>
 Splits a string.
</summary>
</member>
<member name="M:Marvel.Strings.splitRE(System.Char[],System.String)">
<summary>
 Splits a string removing empty entries.
</summary>
</member>
<member name="M:Marvel.Strings.split(System.Char[],System.String)">
<summary>
 Splits a string.
</summary>
</member>
<member name="M:Marvel.Strings.endsWithI(System.String,System.String)">
<summary>
 Determines whether a string ends with a substring ignoring case
</summary>
</member>
<member name="M:Marvel.Strings.endsWith(System.String,System.StringComparison,System.String)">
<summary>
 Determines whether a string ends with a substring.
</summary>
</member>
<member name="M:Marvel.Strings.startsWithI(System.String,System.String)">
<summary>
 Determines whether a string starts with a substring ignoring case.
</summary>
</member>
<member name="M:Marvel.Strings.startsWith(System.String,System.StringComparison,System.String)">
<summary>
 Determines whether a string starts with a substring.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Strings">

</member>
<member name="">

</member>
<member name="T:Marvel.Text">

</member>
<member name="M:Marvel.These.fold``3(Marvel.Monoid{``0},Marvel.These{``1,``2},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
<summary>
 A homomorphism from These to a monoid &apos;z.
</summary>
</member>
<member name="M:Marvel.These.monoid``2(Marvel.Monoid{``0},Marvel.Monoid{``1})">
<summary>
 Coproduct monoid.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.These">

</member>
<member name="M:Marvel.TimedCounterFilter.beforeBatch``2(Marvel.TimedCounter)">
<summary>
 Ticks the counter before invocation of the service.
</summary>
</member>
<member name="M:Marvel.TimedCounterFilter.before``2(Marvel.TimedCounter)">
<summary>
 Ticks the counter before invocation of the service.
</summary>
</member>
<member name="M:Marvel.TimedCounterFilter.afterBatch``2(Marvel.TimedCounter)">
<summary>
 Ticks the counter after invocation of the service.
</summary>
</member>
<member name="M:Marvel.TimedCounterFilter.after``2(Marvel.TimedCounter)">
<summary>
 Ticks the counter after invocation of the service.
</summary>
</member>
<member name="T:Marvel.TimedCounterFilter">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.TorchApi">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Update">
<summary>
 Operations on update monads.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.UrlShortener">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Util">

</member>
<member name="T:Marvel.Validation.Validate`1">
<summary>
 A validation result - either a successs containing the value being validated
 or a list of error strings.
</summary>
</member>
<member name="T:Marvel.Validation.Validate`2">
<summary>
 A validation result - either a successs containing the value being validated
 or a list of errors of type &apos;e.
</summary>
</member>
<member name="M:Marvel.Validation.ApplicativeLaws.interchange``2(``0,Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Application can happen from either side.
</summary>
</member>
<member name="M:Marvel.Validation.ApplicativeLaws.homomorphism``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Lifting a function into an applicative then applying that to an applicative value is the same as lifting the result of the direct application into an applicative.
</summary>
</member>
<member name="M:Marvel.Validation.ApplicativeLaws.composition``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``2,``0},Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Lifting function composition into applicative is the same as applicative apply.
</summary>
</member>
<member name="M:Marvel.Validation.ApplicativeLaws.identity``1(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Applying identity leaves the structure unchanged.
</summary>
</member>
<member name="T:Marvel.Validation.ApplicativeLaws">

</member>
<member name="M:Marvel.Validation.Validate.uriAbsolute``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Absolute Uri.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.uri``1(System.UriKind)">
<summary>
 Uri.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.listLengthLE``2(System.Int32)">
<summary>
 List length less than or equal to.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Validation.Validate.LE``2(``0)">
<summary>
 Less than or equal to.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Validation.Validate.LT``2(``0)">
<summary>
 Less than.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Validation.Validate.GT``2(``0)">
<summary>
 Greater than.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Validation.Validate.GE``2(``0)">
<summary>
 Greater than or equal to.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Validation.Validate.stringLengthMax``1(System.Int32)">
<summary>
 String length max.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.stringLength``1(System.Int32,System.Int32)">
<summary>
 String length range.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.notNullOrEmptyString``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Not null or empty string.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.notEmptyString``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Not empty string.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.notNull``2(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Not null reference.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Marvel.Validation.Validate.validateSeq``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,Microsoft.FSharp.Collections.FSharpList{``2}}})">
<summary>
 Applies a validation function to each element of a sequence and groups the results into a single validation result.
 All validation errors are collected (rather than short-circuiting).
</summary>
</member>
<member name="M:Marvel.Validation.Validate.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,Microsoft.FSharp.Collections.FSharpList{``2}}})">
<summary>
 Composes to validation constructors into one, such that the successful result of the second is propagated.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,Microsoft.FSharp.Collections.FSharpList{``2}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``3,Microsoft.FSharp.Collections.FSharpList{``2}}},``0)">
<summary>
 Composes to validation constructors into one, such that the successful result of the first is propagated.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Composes two choice types, passing the case-2 type of the left value.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Composes two choice types, passing the case-1 type of the right value.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``3}},Microsoft.FSharp.Core.FSharpChoice{``1,Microsoft.FSharp.Collections.FSharpList{``3}})">
<summary>
 Lifts a two argument function to operate over the choice type.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.merge4``5(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``3,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``4,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Monoidal applicative merge.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.merge3``4(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``3,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Monoidal applicative merge.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.merge``3(Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Monoidal applicative merge.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.map4``6(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}}}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``5}},Microsoft.FSharp.Core.FSharpChoice{``1,Microsoft.FSharp.Collections.FSharpList{``5}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``5}},Microsoft.FSharp.Core.FSharpChoice{``3,Microsoft.FSharp.Collections.FSharpList{``5}})">
<summary>
 Maps a function over fource applicatives (validate).
</summary>
</member>
<member name="M:Marvel.Validation.Validate.map3``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``4}},Microsoft.FSharp.Core.FSharpChoice{``1,Microsoft.FSharp.Collections.FSharpList{``4}},Microsoft.FSharp.Core.FSharpChoice{``2,Microsoft.FSharp.Collections.FSharpList{``4}})">
<summary>
 Maps a function over three applicatives (validate).
</summary>
</member>
<member name="M:Marvel.Validation.Validate.map2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``3}},Microsoft.FSharp.Core.FSharpChoice{``1,Microsoft.FSharp.Collections.FSharpList{``3}})">
<summary>
 Maps a function over two applicatives (validate).
</summary>
</member>
<member name="M:Marvel.Validation.Validate.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``2}})">
<summary>
 Lifts a function into an applicative. Note this operator is &lt;$&gt; in Haskell, but F# doesn&apos;t allow $ in operators.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``2}})">
<summary>
 Applies the function to the choice 1 value and returns the result as a choice 1, if matched, 
 otherwise returns the original choice 2 value. (Functor)
</summary>
</member>
<member name="M:Marvel.Validation.Validate.op_LessMultiplyGreater``3">
<summary>
 Sequential application.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.ap``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``2}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{``2}})">
<summary>
 Given a function in a choice and a choice value x, applies the function to the value if available, 
 otherwise propagates the second choice.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.validator``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``1},``0)">
<summary>
 Given a predicate and an error message, creates a validator for a value of type &apos;a.
</summary>
</member>
<member name="M:Marvel.Validation.Validate.failOne``2(``0)">
<summary>
 Creates a validation failure.
</summary>
</member>
<member name="">

</member>
<member name="M:Marvel.Validation.Validate.puree``2(``0)">
<summary>
 Given a value, creates a choice 1.
</summary>
</member>
<member name="T:Marvel.Validation.Validate">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Marvel.Writer">

</member>
</members>
</doc>
